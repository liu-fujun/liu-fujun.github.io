<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>java基础面试题 | Liu's Blog</title><meta name="keywords" content="JAVA,面试"><meta name="author" content="Liu Fujun"><meta name="copyright" content="Liu Fujun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JAVA基础面试JDK1.8、11新特性HaspMap相关HashMap占多少内存根据对象&#x3D;对象头+成员变量+对齐填充，HashMap的初始对象大小为：hashmap：头部（8）+int（4*4）+float（4）+table数组引用（4）+entrySet引用（4）+keySet引用（4）+values引用（4）+padding（4）&#x3D;48字节table：头部（8+4）+长度（4）&#x3D;16字节总共">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础面试题">
<meta property="og:url" content="https://liu-fujun.github.io/interview/java/index.html">
<meta property="og:site_name" content="Liu&#39;s Blog">
<meta property="og:description" content="JAVA基础面试JDK1.8、11新特性HaspMap相关HashMap占多少内存根据对象&#x3D;对象头+成员变量+对齐填充，HashMap的初始对象大小为：hashmap：头部（8）+int（4*4）+float（4）+table数组引用（4）+entrySet引用（4）+keySet引用（4）+values引用（4）+padding（4）&#x3D;48字节table：头部（8+4）+长度（4）&#x3D;16字节总共">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://liu-fujun.github.io/img/river.jpg">
<meta property="article:published_time" content="2021-05-03T01:52:12.000Z">
<meta property="article:modified_time" content="2022-05-14T09:31:40.011Z">
<meta property="article:author" content="Liu Fujun">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liu-fujun.github.io/img/river.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://liu-fujun.github.io/interview/java/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":false,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java基础面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-14 17:31:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/iconfont.css"><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/LFJ.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye1"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw iconfont icon-KJ_005"></i><span> 技术</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw iconfont icon-yuyan"></i><span> 语言</span><i class="iconfont icon-chevron-right"></i></a><ul class="menus_item_child1"><li><a class="site-page child" href="/categories/java/"><i class="fa-fw iconfont icon-java"></i><span> JAVA</span></a></li><li><a class="site-page child" href="/categories/go/"><i class="fa-fw iconfont icon-golang"></i><span> Golang</span></a></li></ul></li><li><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw iconfont icon-rongqi"></i><span> 云原生</span><i class="iconfont icon-chevron-right"></i></a><ul class="menus_item_child1"><li><a class="site-page child" href="/categories/k8s/"><i class="fa-fw iconfont icon-k8s"></i><span> K8s</span></a></li><li><a class="site-page child" href="/categories/openstack/"><i class="fa-fw iconfont icon-openstack"></i><span> OpenStack</span></a></li></ul></li><li><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw iconfont icon-suanfaku"></i><span> 算法</span><i class="iconfont icon-chevron-right"></i></a><ul class="menus_item_child1"><li><a class="site-page child" href="/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"><i class="fa-fw iconfont icon-paixu"></i><span> 排序</span></a></li><li><a class="site-page child" href="/categories/%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95/"><i class="fa-fw iconfont icon-zu24"></i><span> 其他</span></a></li></ul></li><li><a class="site-page child" href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"><i class="fa-fw iconfont icon-solution"></i><span> 其他</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/%E6%97%A5%E5%B8%B8/"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw iconfont icon-list"></i><span> 管理</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-24gf-tags2"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-guidangcunchu"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyuwo"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/river.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Liu's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye1"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw iconfont icon-KJ_005"></i><span> 技术</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw iconfont icon-yuyan"></i><span> 语言</span><i class="iconfont icon-chevron-right"></i></a><ul class="menus_item_child1"><li><a class="site-page child" href="/categories/java/"><i class="fa-fw iconfont icon-java"></i><span> JAVA</span></a></li><li><a class="site-page child" href="/categories/go/"><i class="fa-fw iconfont icon-golang"></i><span> Golang</span></a></li></ul></li><li><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw iconfont icon-rongqi"></i><span> 云原生</span><i class="iconfont icon-chevron-right"></i></a><ul class="menus_item_child1"><li><a class="site-page child" href="/categories/k8s/"><i class="fa-fw iconfont icon-k8s"></i><span> K8s</span></a></li><li><a class="site-page child" href="/categories/openstack/"><i class="fa-fw iconfont icon-openstack"></i><span> OpenStack</span></a></li></ul></li><li><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw iconfont icon-suanfaku"></i><span> 算法</span><i class="iconfont icon-chevron-right"></i></a><ul class="menus_item_child1"><li><a class="site-page child" href="/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"><i class="fa-fw iconfont icon-paixu"></i><span> 排序</span></a></li><li><a class="site-page child" href="/categories/%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95/"><i class="fa-fw iconfont icon-zu24"></i><span> 其他</span></a></li></ul></li><li><a class="site-page child" href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"><i class="fa-fw iconfont icon-solution"></i><span> 其他</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/%E6%97%A5%E5%B8%B8/"><i class="fa-fw iconfont icon-shenghuo"></i><span> 生活</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw iconfont icon-list"></i><span> 管理</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-24gf-tags2"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-guidangcunchu"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-guanyuwo"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java基础面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-03T01:52:12.000Z" title="发表于 2021-05-03 09:52:12">2021-05-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-14T09:31:40.011Z" title="更新于 2022-05-14 17:31:40">2022-05-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java基础面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JAVA基础面试"><a href="#JAVA基础面试" class="headerlink" title="JAVA基础面试"></a>JAVA基础面试</h1><h2 id="JDK1-8、11新特性"><a href="#JDK1-8、11新特性" class="headerlink" title="JDK1.8、11新特性"></a>JDK1.8、11新特性</h2><h2 id="HaspMap相关"><a href="#HaspMap相关" class="headerlink" title="HaspMap相关"></a>HaspMap相关</h2><h3 id="HashMap占多少内存"><a href="#HashMap占多少内存" class="headerlink" title="HashMap占多少内存"></a>HashMap占多少内存</h3><p>根据<code>对象=对象头+成员变量+对齐填充</code>，HashMap的初始对象大小为：<br>hashmap：头部（8）+int（4*4）+float（4）+table数组引用（4）+entrySet引用（4）+keySet引用（4）+values引用（4）+padding（4）=48字节<br>table：头部（8+4）+长度（4）=16字节<br>总共：64个字节。</p>
<h3 id="null值与无序"><a href="#null值与无序" class="headerlink" title="null值与无序"></a>null值与无序</h3><p>HashMap允许<code>null</code>作为键值，当null作为键时，存放在<code>0</code>位置；<br>由于HashMap是根据Key的<code>hashcode</code>进行存放，所以是<code>无序的</code>，如果想要有序则使用<code>LinkedHashMap</code>:</p>
<ul>
<li><code>LinkedHashMap</code>是<code>HashMap的子类</code>，内部有一个<code>双向链表</code>维护键值对的<code>顺序</code>，每个键值对既位于哈希表中，也位于双向链表中。</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>HashMap底层是：<code>数组+链表/红黑树</code>；<br>HashMap默认是一个<code>容量为16</code>的数组，当进行数据存储时，会根据键对应的hashcode选择存放的位置，此时总会出现不同的键但是HashCode一致，需要存放的位置也一样，导致出现<code>哈希冲突</code>，一般的解决方案有：</p>
<ul>
<li>再哈希：就是使用另外的Hash算法再次运算；</li>
<li>开放寻址法：即将发生冲突的位置也加入到hash运算中，得到新的地址；</li>
<li>链地址法：就是在数组每个节点存放的是一个链表，也叫拉链法；</li>
<li>公共溢出区：就是将发生冲突的都放入公共溢出区中；</li>
</ul>
<p>HashMap就是使用的<code>链地址法</code>，每个数组位置存放一个链表。<br>由于数组时，查询一个数据的时间复杂度是<code>O(1)</code>，只要根据hashcode算出对应位置，直接获取即可；<br>当数组节点存放链表时，查询的时间复杂度就会和链表的长度有关，变为<code>O(n)</code>，如果链表过长，查询就会变慢；<br>所以在JDK1.8版本加入了<code>红黑树（二叉平衡树）</code>，当<code>链表长度超过8</code>时，就会转为红黑树，根据红黑树特性，查询的时间复杂度就变为<code>O(logN)</code>；</p>
<h3 id="存值过程"><a href="#存值过程" class="headerlink" title="存值过程"></a>存值过程</h3><p><img src="/interview/java/hashmap.png" alt="hashmap.png"></p>
<ul>
<li>先判断数组<code>是否存在</code>，长度是否为空，如果为空就执行初始化，得到默认容量为16的数组；</li>
<li>然后调用哈希函数获取Key对应的hash值,再根据<code>(n-1) &amp; hash</code>计算其数组下标;<ul>
<li>如果下标位置没有数据，则直接存入；  </li>
<li>如果下标位置有数据：<ul>
<li>如果与要存的key一样，则<code>替换其value</code>即可;</li>
<li>如果不一样，则判断当前是链表还是红黑树<ul>
<li>如果是链表，则进行<code>尾插法</code>，放入链表最后；<ul>
<li>如果链表长度超过<code>8</code>,就把链表转成红黑树；</li>
</ul>
</li>
<li>如果是红黑树，则直接插入树中；<ul>
<li>长度低于<code>6</code>，就把红黑树转回链表;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果数组使用量超过<code>阈值0.75</code>,调用<code>resize方法</code>进行数组扩容。</li>
</ul>
<blockquote>
<p>为什么是(n-1) &amp; hash?<br>首先，hashMap的数组容量是2的n次幂，然后对hashcode进行取余操作时，会发现余数是位运算右移的结果；<br>根据2的n次幂发现每次右移的都是n-1位，所以表达式为：(n-1) &amp; hash</p>
</blockquote>
<h3 id="头插法和尾插法"><a href="#头插法和尾插法" class="headerlink" title="头插法和尾插法"></a>头插法和尾插法</h3><p>在JDK1.7之前使用的是头插法，由于在多线程扩容时，可能会出现环，比如本来是[3,1]，线程1和2都执行扩容，线程1扩容完结果变为[1,3]，线程2执行是就会出现环。<br>在JDK1.8之后改为尾插法，这样可以保证扩容后，依然会哈希冲突的数据，进入链表的前后顺序不变。</p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>创建一个新的数组，其容量为旧数组的两倍，并重新计算旧数组中结点的存储位置。<br>结点在新数组中的位置只有两种：<code>原下标位置</code>或<code>原下标+旧数组的大小</code>。</p>
<h3 id="为什么是线程不安全"><a href="#为什么是线程不安全" class="headerlink" title="为什么是线程不安全"></a>为什么是线程不安全</h3><p>当多个线程同时进行put操作时，可能发生值覆盖（JDk1.7之前还可能发生死循环等问题），所以不是线程安全的。<br>HashTable是线程安全的，它的方法是<code>Synchronize</code>修饰的，通过锁实现了线程安全。</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>ConcurrentHashMap为什么是线程安全，其实就是它的加锁方式（JDK1.7和1.8的区别）：<br>总结：</p>
<ul>
<li>1.7: Segment + HashEntry + ReentrantLock ，锁粒度为Segment；</li>
<li>1.8: HashEntry + synchronized + CAS + 红黑树 ，锁粒度为HashEntry；</li>
</ul>
<p><strong>锁的结构不同：</strong><br>&emsp;&emsp;在JDK1.7中，是基于<code>Segment+HashEntry数组</code>实现的。Segment是Reentrant的子类，而其内部也维护了一个Entry数组，这个Entry数组和HashMap中的Entry数组是一样的。所以说<code>Segment其实是一个锁，可以锁住一段哈希表结构</code>，而ConcurrentHashMap中维护了一个Segment数组，所以是<code>基于分段锁实现</code>的。<br>&emsp;&emsp;在JDK1.8中，采用<code>synchronized+CAS+红黑树</code>来实现的。锁的粒度也从段锁缩小为<code>结点锁</code>；<br><strong>存值过程不同：</strong><br>&emsp;&emsp;在JDK1.7中，要进行<code>两次定位</code>，先对<code>Segment进行定位</code>，再对其<code>内部的数组下标进行定位</code>。定位之后会采用<code>自旋锁+锁膨胀</code>的机制进行加锁，也就是<code>自旋获取锁</code>，当自旋次数<code>超过64</code>时，会发生膨胀，直接陷入<code>阻塞状态</code>，等待唤醒。并且在整个put操作期间都持有锁。<br>&emsp;&emsp;在JDK1.8中只需要<code>一次定位</code>，并且采用<code>CAS+synchronized</code>的机制。如果对应下标处没有结点，说明没有发生哈希冲突，此时直接通过CAS进行插入，若成功，直接返回。若失败，则使用synchronized进行加锁插入。</p>
<h3 id="扩容过程"><a href="#扩容过程" class="headerlink" title="扩容过程"></a>扩容过程</h3><ul>
<li>先传入一个k和v的键值对，不可为空（HashMap是可以为空的），如果为空就直接报错。</li>
<li>接着去判断table是否为空，如果为空就进入初始化阶段。</li>
<li>如果判断数组中某个指定的桶是空的，那就直接把键值对插入到这个桶中作为头节点，而且这个操作不用加锁。</li>
<li>如果这个要插入的桶中的hash值为-1，也就是MOVED状态（也就是这个节点是forwordingNode），那就是说明有线程正在进行扩容操作，那么当前线程就进入协助扩容阶段。</li>
<li>需要把数据插入到链表或者树中，如果这个节点是一个链表节点，那么就遍历这个链表，如果发现有相同的key值就更新value值，如果遍历完了都没有发现相同的key值，就需要在链表的尾部插入该数据。插入结束之后判断该链表节点个数是否大于8，如果大于就需要把链表转化为红黑树存储。</li>
<li>如果这个节点是一个红黑树节点，那就需要按照树的插入规则进行插入。</li>
<li>put结束之后，需要给map已存储的数量+1，在addCount方法中判断是否需要扩容。</li>
</ul>
<h2 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h2><h2 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h2><h1 id="线程与锁"><a href="#线程与锁" class="headerlink" title="线程与锁"></a>线程与锁</h1><h2 id="线程安全与死锁"><a href="#线程安全与死锁" class="headerlink" title="线程安全与死锁"></a>线程安全与死锁</h2><h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><p>&emsp;&emsp;所谓的线程安全，指的是当多个线程访问某一个类（对象或方法）时，对象对应的公共数据区始终都能表现正确，那么这个类（对象或方法）就是线程安全的。<br>也就是说，多个线程同时访问某一个方法，最后执行结果与单线程运行的结果一致，则就是线程安全。</p>
<p><strong>如何保证线程安全？</strong><br>java常见的就是加锁。</p>
<h3 id="死锁的四个条件"><a href="#死锁的四个条件" class="headerlink" title="死锁的四个条件"></a>死锁的四个条件</h3><p><strong>什么是死锁？</strong><br>&emsp;&emsp;死锁就是两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p><strong>产生死锁的四个条件</strong></p>
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li>
<li>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li>
<li>不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</li>
<li>循环等待条件: 若干进程间形成首尾相接循环等待资源的关系。</li>
</ol>
<p><strong>如何避免死锁</strong><br>一般的解决方案分为三种：</p>
<ol>
<li>顺序加锁：按照顺序加锁，防止错乱的加锁导致循环等待；</li>
<li>锁超时：尝试获取锁的时候加一个超时时间，如果到时间还是无法获取，则回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。</li>
<li>死锁检测：当无法获取锁时，增加判断，是不是此时该锁的持有者需要请求自己所持有的资源；</li>
</ol>
<h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>&emsp;&emsp;公平锁是指多个线程按照申请锁的顺序来获取锁，新来的线程看到锁的等待队列不为空，则直接入队。<br>&emsp;&emsp;非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，新的线程来了之后，先去尝试获取锁，获取失败再入队。</p>
<h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><p>&emsp;&emsp;乐观锁是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制（一般是cas）来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);<br>&emsp;&emsp;悲观锁是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作。</p>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p>&emsp;&emsp;Synchronized是实现线程同步的关键字，它所表示的是一个<code>非公平的重量级锁</code>。<br>&emsp;&emsp;Synchronized一般是在<code>方法或者同步代码块</code>上使用，在方法上时，最终是通过<code>ACC_SYNCHRONIZED</code>标志，来告诉JVM这是一个同步方法，进入需要对锁的计数器加1，方法结束后计数器-1；<br>&emsp;&emsp;如果是在同步代码块上，就是通过<code>monitorenter</code>指令进入，然后<code>monitorexit</code>释放锁，在执行<code>monitorenter</code>之前需要尝试获取锁，同样在进入时锁计数器+1，退出释放锁时减一；</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>&emsp;&emsp;Synchronized底层是通过<code>对象头里面的关键字Mark Word信息实现</code>的。<br>&emsp;&emsp;在Mark Word中，记录了锁的状态，持有锁的线程ID等信息；</p>
<h3 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a>加锁流程</h3><p>当线程A来竞争锁：</p>
<ul>
<li>如果竞争成功，则持有锁，MarkWord中的所有者信息就为<code>当前线程的ID，锁计数+1</code>；</li>
<li>如果竞争失败，则进入<code>阻塞队列</code>；</li>
</ul>
<p>当锁释放了，就会从阻塞队列中唤醒线程A，线程A再次竞争如果成功，则持有锁；<br>当线程A执行<code>wait()方法</code>时，则<code>释放锁</code>，并进入<code>等待队列</code>，等待被唤醒；<br>当调用了<code>notify()或者notifyAll()</code>时，线程A唤醒，转入<code>阻塞队列</code>；</p>
<h3 id="为什么是非公平"><a href="#为什么是非公平" class="headerlink" title="为什么是非公平"></a>为什么是非公平</h3><p>原因大致分为两点：</p>
<ol>
<li><p>当持有锁的线程释放锁时，该线程会执行以下两个重要操作：</p>
<ul>
<li>a：先将锁的持有者 owner 属性赋值为 null</li>
<li>b：唤醒等待链表中的一个线程（假定继承者）。<br>在a和b之间，如果有其他线程刚好在尝试获取锁（例如自旋），则可以马上获取到锁。</li>
</ul>
</li>
<li><p>当线程尝试获取锁失败，进入阻塞时，放入链表的顺序，和最终被唤醒的顺序是不一致的，也就是说你先进入链表，不代表你就会先被唤醒。<br>它是根据<code>排队策略（QMode）</code>的设置进行不同的选择，阻塞队列中维护了两个链表，一个<code>_cxq</code>，一个<code>_EntryList</code>:<br>根据排队策略的设置，会决定是从<code>_cxq</code>中取还是<code>_EntryList</code>，或者是把<code>_cxq的头放入_EntryList的头部还是尾部</code>等，所以最终被唤醒的不一定是最早进入阻塞队列的。</p>
</li>
</ol>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p>主要的优化就是引入：偏向锁、轻量级锁、自旋锁、自适应自旋、锁消除、锁粗化。</p>
<p><strong>偏向锁：</strong><br>适用于<code>只有一个线程</code>获取锁，它<code>没有释放</code>的步骤，加锁、解锁不需要消耗额外的资源;</p>
<ol>
<li>首先<code>检查对象头Mark Word</code>中锁标记是否是偏向锁；</li>
<li>检查对象头中记录的<code>线程ID是否是当前线程的ID</code>，如果是说明当前线程已经获得过锁，当前线程将再次获得锁，可以执行同步代码；</li>
<li>如果对象头中的线程ID不是当前线程的ID，则通过<code>CAS操作</code>替换成当前线程的ID，如果替换成功意味着当前线程获得了锁，可以执行同步代码；</li>
<li>如果步骤3的CAS操作失败，则意味着已经有别的线程获得了锁，针对这个锁出现了竞争，<code>偏向锁转为轻量级锁</code>，被挂起的线程被唤醒，线程将按照轻量级锁的机制竞争锁；</li>
</ol>
<p><strong>轻量级锁：</strong><br>轻量级锁的性能介于<code>偏向锁与重量级锁之间</code>，在存在锁竞争的情况下，不需要让线程在阻塞与唤醒状态间切换。<br>其实它的获取步骤主要是在偏向锁时发生了锁竞争，则为了节省开销，直接自旋等待，不需要进入阻塞队列；</p>
<h3 id="Synchronized与Lock"><a href="#Synchronized与Lock" class="headerlink" title="Synchronized与Lock"></a>Synchronized与Lock</h3><ol>
<li>synchronized是一个关键字，而lock是一个接口（里面支持lock、lockInterruptibly、tryLock、unlock、newCondition等方法）。</li>
<li>synchronized是隐式的加锁，lock是显示的加锁。</li>
<li>synchronized可以作用在方法和代码块上，而lock只能作用在代码块上。</li>
<li>synchronized是阻塞式加锁，而lock中的trylock支持非阻塞式加锁。</li>
<li>synchronized没有超时机制，而lock中的trylcok可以支持超时机制。</li>
<li>synchronized不可中断，而lock中的lockInterruptibly可中断的获取锁。</li>
<li>synchronized采用的是monitor对象监视器，lock的底层原理是AQS。</li>
<li>synchronized只有一个同步队列和一个等待队列，而lock有一个同步队列，可以有多个等待队列。</li>
<li>synchronized是非公平锁，而lock可以是公平锁也可以是非公平锁。</li>
<li>synchronized用object的notify方法进行唤醒，而lock用condition进行唤醒。</li>
<li>lock有ReadWriteLock支持并发读。</li>
</ol>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>&emsp;&emsp;<code>volatile</code>也是实现线程之间参数同步的关键字。主要是保证了<code>参数的可见性</code>。<br>&emsp;&emsp;线程工作时，会将用到的参数变量从主内存拷贝到工作内存中，当线程执行完毕的时候，再将工作内存总的变量写入到主内存中。并且在线程执行时，只要操作之间没有数据依赖性，不影响最终结果，指令是可以重排序的。<br>&emsp;&emsp;在多线程的情况下，线程是并行的，所以对同一变量的修改顺序是无序的，指令可能发生重排，最终无法实现线程安全。</p>
<p>&emsp;&emsp;使用了<code>volatile</code>修饰后，当<code>修改</code>变量时，JMM会把该线程对应的<code>本地内存中的共享变量值刷新到主内存</code>。当<code>读</code>一个volatile变量时，JMM会把该线程对应的<code>本地内存置为无效，线程接下来将从主内存读取共享变量</code>。</p>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>&emsp;&emsp;<code>volatile</code>是利用了内存屏障，CPU理论上支持4中内存屏障：</p>
<ol>
<li>LoadLoad：禁止读和读的重排序。</li>
<li>StoreStore：禁止写和写的重排序。</li>
<li>LoadStore：禁止读和写的重排序。</li>
<li>StoreLoad：禁止写和读的重排序。</li>
</ol>
<p>&emsp;&emsp;通过设置内存屏障，来防止指令的重排序，从而防止读写指令的顺序发生变化，比如：</p>
<ol>
<li>在volatile写操作的前面插入一个StoreStore屏障。保证volatile写操作不会和之前的写操作重排序。</li>
<li><strong>在volatile写操作的后面插入一个StoreLoad屏障。保证volatile写操作不会和之后的读操作重排序。</strong></li>
<li>在volatile读操作的后面插入一个LoadLoad屏障+LoadStore屏障。保证volatile读操作不会和之后的读操作、写操作重排序。</li>
</ol>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>默认提供的线程池有四种类型：</p>
<ol>
<li><code>newCachedThreadPool</code>：创建一个可缓存的线程池，如果线程池长度超过处理需求，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li><code>newFixedThreadPool</code>：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待；</li>
<li><code>newScheduledThreadPool</code>：创建一个定长线程池，支持定时及周期性任务执行；</li>
<li><code>newSingleThreadExecutor</code>：创建一个单线程化的线程池，它只会唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO，LIFO，优先级）执行</li>
</ol>
<h3 id="核心参数解析"><a href="#核心参数解析" class="headerlink" title="核心参数解析"></a>核心参数解析</h3><p><strong>corePoolSize：线程池核心线程大小</strong><br><strong>maximumPoolSize：线程池最大线程数量</strong><br><strong>keepAliveTime：多余的空闲线程存活时间</strong><br><strong>unit：空闲线程存活时间单位</strong><br><strong>workQueue：工作队列</strong><br><strong>threadFactory：线程工厂</strong><br><strong>handler：拒绝策略</strong></p>
<ul>
<li><code>AbortPolicy</code>：丢弃任务并抛出<code>RejectedExecutionException</code>异常。（默认这种）；</li>
<li><code>DiscardPolicy</code>：丢弃任务，但是不抛出异常；</li>
<li><code>DiscardOldestPolicy</code>：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） 。也就是当任务被拒绝添加时，会抛弃任务队列中最旧的任务也就是最先加入队列的，再把这个新任务从队尾添加进去，等待执行；</li>
<li><code>CallerRunsPolicy</code>：谁调用，谁处理。由调用线程（即提交任务给线程池的线程）处理该任务，如果线程池已经被shutdown则直接丢弃；</li>
</ul>
<p><img src="/interview/java/threadpool.png" alt="threadpool.png"></p>
<h1 id="JVM内存与类加载"><a href="#JVM内存与类加载" class="headerlink" title="JVM内存与类加载"></a>JVM内存与类加载</h1><h2 id="类加载流程"><a href="#类加载流程" class="headerlink" title="类加载流程"></a>类加载流程</h2><p>大致分为5步：</p>
<ol>
<li><strong>加载</strong><ul>
<li>通过全类名获取定义此类的二进制字节流；</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构；</li>
<li>在内存中生成一个代表该类的<code>Class对象</code>，作为方法区这些数据的访问入口；</li>
</ul>
</li>
<li><strong>验证</strong><ul>
<li><code>文件格式验证</code>，即是否符合class文件要求；</li>
<li><code>元数据验证</code>，即是否符合java语义；</li>
<li><code>字节码验证</code>，主要是验证控制流、逻辑语义等防止危害jvm；</li>
<li><code>符号引用验证</code>，保证解析正常进行； </li>
</ul>
</li>
<li><strong>准备</strong><ul>
<li>正式为<code>类变量（即静态变量）</code>分配内存并设置类变量<code>初始值</code>的阶段，这些内存都将在方法区中分配。</li>
</ul>
</li>
<li><strong>解析</strong><ul>
<li>将常量池内的符号引用替换为直接引用的过程；</li>
<li>主要针对<code>类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符</code>7类符号引用进行。 </li>
</ul>
</li>
<li><strong>初始化</strong><ul>
<li>类加载的<code>最后一步</code>，这一步JVM才开始真正执行类中定义的代码，完成赋值等；</li>
</ul>
</li>
</ol>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>JVM的类加载机制为：双亲委派机制；<br>默认的加载器分为：</p>
<ol>
<li>启动类加载器（<code>Bootstrap classLoader</code>）：主要负责加载<code>java的lib库</code>；</li>
<li>扩展类加载器（<code>ExtClassLoader</code>）：主要负责加载<code>java的扩展目录</code>；</li>
<li>系统类加载器（<code>AppClassLoader</code>）：主要负责<code>项目路径</code>下的lib加载；</li>
<li>自定义加载器（<code>ConsumerClassLoader</code>）：自定义加载路径下的类；</li>
</ol>
<h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><p>需要加载一个类时，如果有自定义加载器，则自定义加载器不加载，交给系统类加载器（或者叫<code>应用类加载器</code>）；<br>同理，系统类加载器不加载，先让扩展类加载器去尝试加载；<br>扩展类也不直接加载，先让启动类加载器去尝试加载，如果启动类加载器没有加载到，再自己尝试，然后逐级向下；</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ol>
<li><code>防止jdk核心代码被修改</code>，比如自己写的String类，不能覆盖JDK里面的String类；</li>
<li><code>防止重复加载</code>，当父加载器已经加载了该类时，子加载器无需再加载，保证被加载类的唯一性；</li>
</ol>
<h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>JVM内存结构可以分为两块：</p>
<ol>
<li><code>线程私有</code>：只有当<code>前线程能访问</code>数据的区域，线程之间不能共享，线程独享区随线程的创建而创建，<code>随线程的销毁而被回收</code>；<ul>
<li><strong>程序计数器</strong>：程序计数器会记录当前线程要执行指令的内存地址，不会发生内存溢出；</li>
<li><strong>虚拟机栈</strong>：每一个线程都会对应一个虚拟机栈，线程中的每个方法都会创建一个栈帧，存放本次方法执行过程中所需要的所有数据。</li>
<li><strong>本地方法栈</strong>：维护非Java语句执行过程中产生的数据；</li>
</ul>
</li>
<li><code>线程共享</code>：所有线程都可以访问的区域，当线程被销毁的时候，共享区的数据不会立即回收，需要等待达到<code>垃圾回收</code>的阈值之后才会进行回收。<ul>
<li><strong>堆</strong>：此内存区域的唯一目的就是存放对象实例，<code>几乎所有</code>的对象实例都在这里分配内存;也是GC主要发生的区域；<ul>
<li>新生代：新创建的对象都是从新生代分配内存，新生代由<code>EdenSpace（伊甸园区）</code>和两块相同大小的<code>Survivor Space(幸存者区，通常又称S0和S1或From和To)</code>构成；<ol>
<li>新生代对象在经历每次GC的时候，如果没有被回收，则对象的年龄+1。当年龄超过阈值(默认15)的时候,便会进入老年代。 </li>
</ol>
</li>
<li>老年代：存放经过多次新生代GC仍然存活的对象，新建的对象也有可能直接进入老年代，主要有两种情况：<ol>
<li>大对象； </li>
<li>大的数组对象，且数组中无引用外部对象。</li>
</ol>
</li>
</ul>
</li>
<li><strong>方法区</strong>：此区域存放了对象相关信息，包括全限定名、除了常量以外的所有类（静态）变量、常量池（常量数据以及对其他类型的符号引用）等；</li>
</ul>
</li>
</ol>
<h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><h3 id="如何判断对象存活"><a href="#如何判断对象存活" class="headerlink" title="如何判断对象存活"></a>如何判断对象存活</h3><p>主要分为两种：<code>引用计数算法</code>和<code>可达性分析算法</code>；</p>
<ol>
<li>引用计数法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1；任何时刻计数器为0的对象就是可回收的。但是无法处理循环引用问题。</li>
<li>可达性分析：从GC Root开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</li>
</ol>
<h3 id="引用分类"><a href="#引用分类" class="headerlink" title="引用分类"></a>引用分类</h3><ol>
<li><strong>强引用</strong><br><code>Object o = new Object()</code>就是一种强引用关系。无论任何情况下，只要强引用关系还存在，垃圾回收器就不会回收掉被引用的对象。</li>
<li><strong>软引用 SoftReference</strong><br>即有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</li>
<li><strong>弱引用 WeakReference</strong><br>即非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</li>
<li><strong>虚引用PhantomReference</strong><br>这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系。</li>
</ol>
<h3 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h3><ol>
<li>复制算法：将可用内存按容量分成<code>大小相等的两块</code>，每次只使用其中的一块。当这一块内存用完，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。<code>新生代的幸存者区</code>就是使用的复制算法；<ul>
<li>缺点：只能使用内存的一半，代价高；</li>
</ul>
</li>
<li>标记-整理算法：对对象进行标记，然后让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存；</li>
<li>标记-清除算法：标记所有需要回收的对象，标记完成后统一回收所有被标记的对象；<ul>
<li>缺点：效率不高，且产生大量不连续的内存碎片；</li>
</ul>
</li>
<li>分代收集：根据堆的不同部分，使用不同的垃圾回收算法；    </li>
</ol>
<h2 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h2><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-XX:+AlwaysPreTouch</td>
<td align="left">JVM启动时分配内存，非使用时再分配</td>
</tr>
<tr>
<td align="left">-XX:ErrorFile= filename</td>
<td align="left">崩溃日志</td>
</tr>
<tr>
<td align="left">-XX:+TraceClassLoading</td>
<td align="left">跟踪类加载信息</td>
</tr>
<tr>
<td align="left">-XX:+PrintClassHistogram</td>
<td align="left">按下Ctr+ Break后，打印类的信息</td>
</tr>
<tr>
<td align="left">-Xmx -Xms</td>
<td align="left">最大堆和最小堆</td>
</tr>
<tr>
<td align="left">-xx:permSize, -xx:metaspaceSize</td>
<td align="left">永久代/元数据空间</td>
</tr>
<tr>
<td align="left">-XX:+HeapDumpOnOutOfMemoryError</td>
<td align="left">0OM时导出堆到文件</td>
</tr>
<tr>
<td align="left">-XX:+HeapDumpPath</td>
<td align="left">OOM时堆导出的路径</td>
</tr>
<tr>
<td align="left">-XX:+OnOutOfMemoryError</td>
<td align="left">JVM启动时分配内存，非使用时再分配在OOM时，执行一个脚本</td>
</tr>
<tr>
<td align="left">-Xloggc:/opt/gc.log</td>
<td align="left">通过这个参数可以将GC日志进行输出到指定文件</td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Liu Fujun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://liu-fujun.github.io/interview/java/">https://liu-fujun.github.io/interview/java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://liu-fujun.github.io" target="_blank">Liu's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/img/river.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/others/rbac2/"><img class="prev-cover" src="/img/RBAC.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">关于RBAC的总结-下</div></div></a></div><div class="next-post pull-right"><a href="/spring/springaop/"><img class="next-cover" src="/img/spring.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring学习笔记-AOP基础与源码</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/spring/springaop/" title="Spring学习笔记-AOP基础与源码"><img class="cover" src="/img/spring.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-12</div><div class="title">Spring学习笔记-AOP基础与源码</div></div></a></div><div><a href="/spring/springbean/" title="Spring学习笔记-Bean生命周期"><img class="cover" src="/img/spring.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-11</div><div class="title">Spring学习笔记-Bean生命周期</div></div></a></div><div><a href="/spring/springbeancycle/" title="Spring学习笔记-循环依赖"><img class="cover" src="/img/spring.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-12</div><div class="title">Spring学习笔记-循环依赖</div></div></a></div><div><a href="/spring/springioc/" title="Spring学习笔记-IOC原理及配置"><img class="cover" src="/img/spring.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-11</div><div class="title">Spring学习笔记-IOC原理及配置</div></div></a></div><div><a href="/spring/springioccode/" title="Spring学习笔记-IOC源码解析"><img class="cover" src="/img/spring.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-11</div><div class="title">Spring学习笔记-IOC源码解析</div></div></a></div><div><a href="/java/java-dynamic-proxy/" title="Java学习笔记-动态代理"><img class="cover" src="/img/java.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-23</div><div class="title">Java学习笔记-动态代理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/LFJ.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Liu Fujun</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/liu-fujun" target="_blank" title="Github"><i class="iconfont icon-github card_icon"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎大家光临小站~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95"><span class="toc-number">1.</span> <span class="toc-text">JAVA基础面试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK1-8%E3%80%8111%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.</span> <span class="toc-text">JDK1.8、11新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HaspMap%E7%9B%B8%E5%85%B3"><span class="toc-number">1.2.</span> <span class="toc-text">HaspMap相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%8D%A0%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98"><span class="toc-number">1.2.1.</span> <span class="toc-text">HashMap占多少内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null%E5%80%BC%E4%B8%8E%E6%97%A0%E5%BA%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">null值与无序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%80%BC%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">存值过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E6%8F%92%E6%B3%95%E5%92%8C%E5%B0%BE%E6%8F%92%E6%B3%95"><span class="toc-number">1.2.5.</span> <span class="toc-text">头插法和尾插法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9"><span class="toc-number">1.2.6.</span> <span class="toc-text">扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">1.2.7.</span> <span class="toc-text">为什么是线程不安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">1.3.</span> <span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">扩容过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer%E5%92%8CStringBuilder"><span class="toc-number">1.4.</span> <span class="toc-text">StringBuffer和StringBuilder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.</span> <span class="toc-text">抽象类与接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81"><span class="toc-number">2.</span> <span class="toc-text">线程与锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E6%AD%BB%E9%94%81"><span class="toc-number">2.1.</span> <span class="toc-text">线程安全与死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">什么是线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.1.2.</span> <span class="toc-text">死锁的四个条件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">锁分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">公平锁与非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">2.2.2.</span> <span class="toc-text">乐观锁与悲观锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Synchronized"><span class="toc-number">2.3.</span> <span class="toc-text">Synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.1.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">加锁流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3"><span class="toc-number">2.3.3.</span> <span class="toc-text">为什么是非公平</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.4.</span> <span class="toc-text">锁优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized%E4%B8%8ELock"><span class="toc-number">2.3.5.</span> <span class="toc-text">Synchronized与Lock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-number">2.4.</span> <span class="toc-text">volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">2.4.1.</span> <span class="toc-text">内存屏障</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.5.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="toc-number">2.5.1.</span> <span class="toc-text">核心参数解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.</span> <span class="toc-text">JVM内存与类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">类加载流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">加载过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84"><span class="toc-number">3.2.2.</span> <span class="toc-text">好处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.</span> <span class="toc-text">内存结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">GC算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB"><span class="toc-number">3.4.1.</span> <span class="toc-text">如何判断对象存活</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%88%86%E7%B1%BB"><span class="toc-number">3.4.2.</span> <span class="toc-text">引用分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.3.</span> <span class="toc-text">常见算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98"><span class="toc-number">3.5.</span> <span class="toc-text">参数调优</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/interview/netty/" title="无题"><img src="/img/river.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/interview/netty/" title="无题">无题</a><time datetime="2022-05-03T06:18:47.977Z" title="发表于 2022-05-03 14:18:47">2022-05-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/interview/golang/" title="无题"><img src="/img/river.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/interview/golang/" title="无题">无题</a><time datetime="2022-05-03T06:18:21.225Z" title="发表于 2022-05-03 14:18:21">2022-05-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/interview/zookeeper/" title="无题"><img src="/img/river.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/interview/zookeeper/" title="无题">无题</a><time datetime="2022-05-03T06:18:10.150Z" title="发表于 2022-05-03 14:18:10">2022-05-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/interview/spring/" title="无题"><img src="/img/river.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/interview/spring/" title="无题">无题</a><time datetime="2022-05-03T06:17:46.726Z" title="发表于 2022-05-03 14:17:46">2022-05-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/interview/mq/" title="无题"><img src="/img/river.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/interview/mq/" title="无题">无题</a><time datetime="2022-05-03T06:17:33.660Z" title="发表于 2022-05-03 14:17:33">2022-05-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By Liu Fujun</div><!--if theme.footer.copyright--><!--  .framework-info--><!--    span= _p('footer.framework') + ' '--><!--    a(href='https://hexo.io')= 'Hexo'--><!--    span.footer-separator |--><!--    span= _p('footer.theme') + ' '--><!--    a(href='https://github.com/jerryc127/hexo-theme-butterfly')= 'Butterfly'--><div class="footer_custom_text">每天进步一点点</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>