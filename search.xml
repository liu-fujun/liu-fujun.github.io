<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于蓝绿发布、灰度以及滚动发布的记录</title>
      <link href="/2022/02/09/deploy-desc/"/>
      <url>/2022/02/09/deploy-desc/</url>
      
        <content type="html"><![CDATA[<h2 id="蓝绿发布"><a href="#蓝绿发布" class="headerlink" title="蓝绿发布"></a>蓝绿发布</h2><p>项目逻辑上分为AB组，在项目升级时，首先把A组从负载均衡中摘除，进行新版本的部署。B组仍然继续提供服务。</p><p><img src="/2022/02/09/deploy-desc/d1.png" alt="deployment.png"></p><p>当A组升级完毕，负载均衡重新接入A组，再把B组从负载列表中摘除，进行新版本的部署。A组重新提供服务。</p><p><img src="/2022/02/09/deploy-desc/d1-1.png" alt="deployment1.png"></p><p>最后，B组也升级完成，负载均衡重新接入B组，此时，AB组版本都已经升级完成，并且都对外提供服务。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>如果出问题，影响范围较大；</li><li>发布策略简单；</li><li>用户无感知，平滑过渡；</li><li>升级/回滚速度快。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>需要准备正常业务使用资源的两倍以上服务器，防止升级期间单组无法承载业务突发；</li><li>短时间内浪费一定资源成本；</li><li>基础设施无改动，增大升级稳定性。</li></ol><p>蓝绿发布在早期物理服务器时代，还是比较昂贵的，由于云计算普及，成本也大大降低。</p><h2 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h2><p>灰度发布只升级部分服务，即让一部分用户继续用老版本，一部分用户开始用新版本，如果用户对新版本没什么意见，那么逐步扩大范围，把所有用户都迁移到新版本上面来。</p><p><img src="/2022/02/09/deploy-desc/gray.png" alt="gray.png"></p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol><li>保证整体系统稳定性，在初始灰度的时候就可以发现、调整问题，影响范围可控；</li><li>新功能逐步评估性能，稳定性和健康状况，如果出问题影响范围很小，相对用户体验也少；</li><li>用户无感知，平滑过渡。</li></ol><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>自动化要求高</li></ol><h3 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h3><ol><li>从LB摘掉灰度服务器，升级成功后再加入LB；</li><li>少量用户流量到新版本；</li><li>如果灰度服务器测试成功，升级剩余服务器。</li></ol><p>灰度发布是通过切换线上并存版本之间的路由权重，逐步从一个版本切换为另一个版本的过程。</p><h2 id="滚动发布"><a href="#滚动发布" class="headerlink" title="滚动发布"></a>滚动发布</h2><p>滚动发布是指每次只升级一个或多个服务，升级完成后加入生产环境，不断执行这个过程，直到集群中的全部旧版本升级新版本。</p><p><img src="/2022/02/09/deploy-desc/rolling.png" alt="roll.png"></p><ul><li>红色：正在更新的实例</li><li>蓝色：更新完成并加入集群的实例</li><li>绿色：正在运行的实例</li></ul><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ol><li>用户无感知，平滑过渡；</li><li>节约资源。</li></ol><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ol><li>部署时间慢，取决于每阶段更新时间；</li><li>发布策略较复杂；</li><li>无法确定OK的环境，不易回滚。</li></ol><h3 id="部署过程-1"><a href="#部署过程-1" class="headerlink" title="部署过程"></a>部署过程</h3><ol><li>先升级1个副本，主要做部署验证；</li><li>每次升级副本，自动从LB上摘掉，升级成功后自动加入集群；</li><li>事先需要有自动更新策略，分为若干次，每次数量/百分比可配置；</li><li>回滚是发布的逆过程，先从LB摘掉新版本，再升级老版本，这个过程一般时间比较长；</li><li>自动化要求高。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>综上所述，三种方式均可以做到平滑式升级，在升级过程中服务仍然保持服务的连续性，升级对外界是无感知的。那生产上选择哪种部署方法最合适呢？这取决于哪种方法最适合你的业务和技术需求。如果你们运维自动化能力储备不够，肯定是越简单越好，建议蓝绿发布，如果业务对用户依赖很强，建议灰度发布。如果是K8S平台，滚动更新是现成的方案，建议先直接使用。</p><ul><li>蓝绿发布：两套环境交替升级，旧版本保留一定时间便于回滚。</li><li>灰度发布：根据比例将老版本升级，例如80%用户访问是老版本，20%用户访问是新版本。</li><li>滚动发布：按批次停止老版本实例，启动新版本实例。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署方式 </tag>
            
            <tag> 滚动更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s-schedule</title>
      <link href="/2022/02/08/k8s-schedule/"/>
      <url>/2022/02/08/k8s-schedule/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>k8s-network</title>
      <link href="/2022/02/08/k8s-network/"/>
      <url>/2022/02/08/k8s-network/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>k8s-security</title>
      <link href="/2022/02/08/k8s-security/"/>
      <url>/2022/02/08/k8s-security/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>k8s-config</title>
      <link href="/2022/02/08/k8s-config/"/>
      <url>/2022/02/08/k8s-config/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>k8s-ha</title>
      <link href="/2022/02/08/k8s-ha/"/>
      <url>/2022/02/08/k8s-ha/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>k8s-volume</title>
      <link href="/2022/02/08/k8s-volume/"/>
      <url>/2022/02/08/k8s-volume/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>k8s service 笔记</title>
      <link href="/2022/02/08/k8s-service/"/>
      <url>/2022/02/08/k8s-service/</url>
      
        <content type="html"><![CDATA[<h2 id="Service-简介"><a href="#Service-简介" class="headerlink" title="Service 简介"></a>Service 简介</h2><p>通过Deployment来创建一组Pod来提供具有高可用性的服务。虽然每个Pod都会分配一个单独的Pod IP，然而却存在如下两问题：</p><ul><li>Pod IP仅仅是集群内可见的虚拟IP，外部无法访问。</li><li>Pod IP会随着Pod的销毁而消失，当Deployment对Pod进行动态伸缩时，Pod IP可能随时随地都会变化。</li></ul><p>在实际应用中，如果通过Nginx配置后端服务地址的话，由于 Pod ip 会出现变动，每次都需要手动修改配置文件，不方便。<br>当然也可以使用ZooKeeper或者ETCD等注册中心工具，实现服务的自动注册与发现，动态更新配置即可。</p><p>因此，Kubernetes中的Service对象就是解决以上问题的实现服务发现核心关键。</p><ul><li>Service能够提供负载均衡的能力，但是在使用上有以下限制。只提供<code> 4 层负载均衡</code>能力，而没有 7 层功能，但有时我们可能需要更多的匹配规则来转发请求，这点上 4 层负载均衡是不支持的</li></ul><h2 id="代理-kube-proxy"><a href="#代理-kube-proxy" class="headerlink" title="代理 kube-proxy"></a>代理 kube-proxy</h2><p>一个Kubernetes的Service是一种抽象，它定义了一组Pods的逻辑集合和一个用于访问它们的策略（有的时候被称之为微服务）。一个Service的目标Pod集合通常是由<code>Label Selector</code> 来决定的。</p><p>Pod的IP实际路由到一个固定的目的地，而Service 的 IP 实际上不能通过单个主机来进行应答。相反，我们使用 iptables（Linux 中的数据包处理逻辑）来定义一个虚拟IP地址（VIP），它可以根据需要透明地进行重定向。当客户端连接到 VIP 时，它们的流量会自动地传输到一个合适的Endpoint。环境变量和 DNS，实际上会根据 Service 的 VIP 和端口来进行填充。</p><p>kube-proxy支持三种代理模式: <code>用户空间，iptables和IPVS</code>；它们各自的操作略有不同。</p><h3 id="Userspace代理模式"><a href="#Userspace代理模式" class="headerlink" title="Userspace代理模式"></a>Userspace代理模式</h3><h3 id="iptables代理模式"><a href="#iptables代理模式" class="headerlink" title="iptables代理模式"></a>iptables代理模式</h3><h3 id="PVS代理模式"><a href="#PVS代理模式" class="headerlink" title="PVS代理模式"></a>PVS代理模式</h3><h2 id="Service-类型"><a href="#Service-类型" class="headerlink" title="Service 类型"></a>Service 类型</h2><ul><li>ClusterIp：默认类型，自动分配一个仅 Cluster 内部可以访问的虚拟 IP;</li><li>NodePort：在 ClusterIP 基础上为 Service 在每台机器上绑定一个端口，这样就可以通过 :NodePort 来访问该服务;</li><li>LoadBalancer：在 NodePort 的基础上，借助 cloud provider 创建一个外部负载均衡器，并将请求转发到NodePort。是付费服务，而且价格不菲;</li><li>ExternalName：把集群外部的服务引入到集群内部来，在集群内部直接使用。没有任何类型代理被创建，这只有 kubernetes 1.7 或更高版本的 kube-dns 才支持;</li></ul><h3 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h3><h3 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h3><h3 id="LoadBalance"><a href="#LoadBalance" class="headerlink" title="LoadBalance"></a>LoadBalance</h3><h3 id="ExternalName"><a href="#ExternalName" class="headerlink" title="ExternalName"></a>ExternalName</h3><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><h2 id="ingress网络"><a href="#ingress网络" class="headerlink" title="ingress网络"></a>ingress网络</h2>]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> kubernetes </tag>
            
            <tag> 容器 </tag>
            
            <tag> service </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s中控制器详解</title>
      <link href="/2022/02/08/k8s-controller/"/>
      <url>/2022/02/08/k8s-controller/</url>
      
        <content type="html"><![CDATA[<h2 id="常见Pod控制器"><a href="#常见Pod控制器" class="headerlink" title="常见Pod控制器"></a>常见Pod控制器</h2><ol><li>ReplicaSet:适合无状态的服务部署<br>用户创建指定数量的pod副本数量，确保pod副本数量符合预期状态，并且支持滚动式自动扩容和缩容功能。<br>ReplicaSet主要三个组件组成：<br>（1）用户期望的pod副本数量<br>（2）标签选择器，判断哪个pod归自己管理<br>（3）当现存的pod数量不足，会根据pod资源模板进行新建<br>帮助用户管理无状态的pod资源，精确反应用户定义的目标数量，但是RelicaSet不是直接使用的控制器，而是使用Deployment。</li><li>deployment：适合无状态的服务部署工作在ReplicaSet之上，用于管理无状态应用，目前来说最好的控制器。支持滚动更新和回滚功能，还提供声明式配置。</li><li>StatefullSet：适合有状态的服务部署。需要学完存储卷后进行系统学习。</li><li>DaemonSet：一次部署，所有的node节点都会部署，例如一些典型的应用场景：<ul><li>运行集群存储 daemon，例如在每个Node上运行 glusterd、ceph</li><li>在每个Node上运行日志收集 daemon，例如 fluentd、 logstash</li><li>在每个Node上运行监控 daemon，例如 Prometheus Node Exporter<br>用于确保集群中的每一个节点只运行特定的pod副本，通常用于实现系统级后台任务。比如ELK服<br>务<br>特性：服务是无状态的<br>服务必须是守护进程</li></ul></li><li>Job：一次性的执行任务。 只要完成就立即退出，不需要重启或重建。</li><li>Cronjob：周期性的执行任务。 周期性任务控制，不需要持续后台运行。</li></ol><h2 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h2><p>&emsp;&emsp;ReplicationController用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的Pod来替代；而如果异常多出来的容器也会自动回收。<br>&emsp;&emsp;ReplicaSet跟ReplicationController没有本质的不同，只是名字不一样，并且ReplicaSet支持集合式的selector。<br>&emsp;&emsp;虽然ReplicaSet可以独立使用，但一般还是建议使用 Deployment 来自动管理ReplicaSet，这样就无需担心跟其他机制的不兼容问题（比如ReplicaSet不支持rolling-update但Deployment支持）。</p><h3 id="ReplicationController"><a href="#ReplicationController" class="headerlink" title="ReplicationController"></a>ReplicationController</h3><p>Replication Controller 简称 RC，实际上 RC 和 RS 的功能几乎一致，唯一的一个区别就是 RC 只支持基于等式的 selector（env=dev或environment!=qa），但 RS 还支持基于集合的 selector。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rc</span></span><br><span class="line">selector: </span><br><span class="line">  app: nginx</span><br><span class="line"><span class="meta">  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rs</span></span><br><span class="line">selector:  </span><br><span class="line">  matchLabels:</span><br><span class="line">    app: nginx</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">selector:</span><br><span class="line">  matchExpressions:  # 该选择器要求 Pod 包含名为 app 的标签</span><br><span class="line">  - key: app</span><br><span class="line">    operator: In</span><br><span class="line">    values:  # 并且标签的值必须是 nginx</span><br><span class="line">    - nginx </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ReplicaSet模板说明"><a href="#ReplicaSet模板说明" class="headerlink" title="ReplicaSet模板说明"></a>ReplicaSet模板说明</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>        <span class="comment">#api版本定义</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span>           <span class="comment">#定义资源类型为ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span>                  <span class="comment">#元数据定义</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">replicasetdemo</span>  </span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">replicasetdemo</span></span><br><span class="line"><span class="attr">spec:</span>                       <span class="comment">#ReplicaSet的规格定义</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span>               <span class="comment">#定义副本数量为3个</span></span><br><span class="line">  <span class="attr">template:</span>            <span class="comment">#pod的模板定义</span></span><br><span class="line">    <span class="attr">metadata:</span>         <span class="comment">#pod的元数据定义</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">replicasetdemo</span>  <span class="comment">#自定义pod的名称</span></span><br><span class="line">      <span class="attr">labels:</span>              <span class="comment">#定义pod的标签，需要和selector定义的标签一致，也可以多出其他标签</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">replicasetdemo</span></span><br><span class="line">    <span class="attr">spec:</span>         <span class="comment">#pod的规格定义</span></span><br><span class="line">      <span class="attr">containers:</span>    <span class="comment">#容器定义</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">replicasetdemo</span>    <span class="comment">#容器名称</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.17.10-alpine</span> <span class="comment">#容器镜像</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">ports:</span>  <span class="comment">#暴露端口</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">selector:</span>    <span class="comment">#标签选择器，定义匹配pod的标签</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">replicasetdemo</span></span><br></pre></td></tr></table></figure><p>当然，可以通过kubectl命令行方式获取更加详细信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl explain rs</span><br><span class="line">kubectl explain rs.spec</span><br><span class="line">kubectl explain rs.spec.template.spec</span><br></pre></td></tr></table></figure><p>常用的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行ReplicaSet</span></span><br><span class="line">kubectl apply -f replicasetdemo.yml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看rs控制器</span></span><br><span class="line">kubectl get rs</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod信息</span></span><br><span class="line">kubectl get pod</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod详细信息</span></span><br><span class="line">kubectl describe pod replicasetdemo-7fdd7b5f67-5gzfg</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试controller控制器下的pod删除、重新被controller控制器拉起</span></span><br><span class="line">kubectl delete pod --all</span><br><span class="line">kubectl get pod</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改pod的副本数量:通过命令行方式</span></span><br><span class="line">kubectl scale replicaset replicasetdemo --replicas=8</span><br><span class="line">kubectl get rs</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改pod的副本数量:通过资源清单方式</span></span><br><span class="line">kubectl edit replicasets.apps replicasetdemo</span><br><span class="line">kubectl get rs</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示pod的标签</span></span><br><span class="line">kubectl get pod --show-labels</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改pod标签(label)</span></span><br><span class="line">kubectl label pod replicasetdemo-652lc app=lagou --overwrite=True</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次显示pod的标签：发现多了一个pod，原来的rs中又重新拉起一个pod，说明rs是通过label去管理pod</span></span><br><span class="line">kubectl get pod --show-labels</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除rs</span></span><br><span class="line">kubectl delete rs replicasetdemo</span><br></pre></td></tr></table></figure><p>最后，总结一下RC（ReplicaSet）的一些特性和作用：</p><ul><li>在绝大多数情况下，我们通过定义一个RC实现Pod的创建及副本数量的自动控制;</li><li>在RC里包括完整的Pod定义模板;</li><li>RC通过Label Selector机制实现对Pod副本的自动控制;</li><li>通过改变RC里Pod副本数量，可以实现Pod的扩容和缩容;</li><li>通过改变RC里Pod模板中的镜像版本，可以实现滚动升级;</li></ul><h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p>&emsp;&emsp;Deployment是kubernetes在1.2版本中引入的新概念，用于更好的解决Pod的编排问题，为此，Deployment在内部使用了ReplicaSet来实现目的，我们可以把Deployment理解为ReplicaSet的一次升<br>级，两者的相似度超过90%<br>Deployment的使用场景有以下几个：</p><ul><li>创建一个Deployment对象来生成对应的ReplicaSet并完成Pod副本的创建；</li><li>检查Deployment的状态来看部署动作是否完成（Pod副本数量是否达到了预期的值）；</li><li>更新Deployment以创建新的Pod（比如镜像升级）；</li><li>如果当前Deployment不稳定，可以回滚到一个早先的Deployment版本；</li><li>暂停Deployment以便于一次性修改多个PodTemplateSpec的配置项，之后在恢复Deployment，进行新的发布；</li><li>扩展Deployment以应对高负载；</li><li>查看Deployment的状态，以此作为发布是否成功的标志；</li><li>清理不在需要的旧版本ReplicaSet；</li></ul><p>详细信息可以使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl explain deploy</span><br><span class="line">kubectl explain deploy.spec</span><br><span class="line">kubectl explain deploy.spec.template.spec</span><br></pre></td></tr></table></figure><p>Pod 依赖的控制器 RS 实际上被的 Deployment 控制着，<br>Pod、ReplicaSet、Deployment 三者之间的关系图如下：<br><img src="/2022/02/08/k8s-controller/deployment.png" alt="deployment.png"></p><h3 id="Deployment模板说明"><a href="#Deployment模板说明" class="headerlink" title="Deployment模板说明"></a>Deployment模板说明</h3><p>基本与ReplicaSet一致。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>        <span class="comment">#api版本定义</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>           <span class="comment">#定义资源类型为Deployment</span></span><br><span class="line"><span class="attr">metadata:</span>                  <span class="comment">#元数据定义</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">deploymentdemo</span>  </span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">deploymentdemo</span></span><br><span class="line"><span class="attr">spec:</span>                       <span class="comment">#ReplicaSet的规格定义</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span>               <span class="comment">#定义副本数量为3个</span></span><br><span class="line">  <span class="attr">template:</span>            <span class="comment">#pod的模板定义</span></span><br><span class="line">    <span class="attr">metadata:</span>         <span class="comment">#pod的元数据定义</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">deploymentdemo</span>  <span class="comment">#自定义pod的名称</span></span><br><span class="line">      <span class="attr">labels:</span>              <span class="comment">#定义pod的标签，需要和selector定义的标签一致，也可以多出其他标签</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">deploymentdemo</span></span><br><span class="line">    <span class="attr">spec:</span>         <span class="comment">#pod的规格定义</span></span><br><span class="line">      <span class="attr">containers:</span>    <span class="comment">#容器定义</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">deploymentdemo</span>    <span class="comment">#容器名称</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.17.10-alpine</span> <span class="comment">#容器镜像</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="attr">ports:</span>  <span class="comment">#暴露端口</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">minReadySeconds:</span> <span class="number">5</span> <span class="comment"># k8s在等待设置的时间后才进行升级。默认为0</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 更新策略</span></span><br><span class="line">     <span class="attr">type:</span> <span class="string">RollingUpdate</span>  <span class="comment"># 指定更新策略：滚动更新RollingUpdate和全部重新创建Recreate</span></span><br><span class="line">     <span class="attr">rollingUpdate:</span></span><br><span class="line">        <span class="attr">maxSurge:</span> <span class="number">1</span> <span class="comment"># 最多可以比原先设置多出的 Pod 数量</span></span><br><span class="line">        <span class="attr">maxUnavailable:</span> <span class="number">1</span> <span class="comment"># 升级过程中最多有多少个 Pod 处于无法提供服务的状态</span></span><br><span class="line">  <span class="attr">selector:</span>    <span class="comment">#标签选择器，定义匹配pod的标签</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">deploymentdemo</span></span><br></pre></td></tr></table></figure><h3 id="镜像更新命令"><a href="#镜像更新命令" class="headerlink" title="镜像更新命令"></a>镜像更新命令</h3><p>通过命令行修改镜像版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 升级nginx镜像版本为1.18.0</span></span><br><span class="line">kubectl set image deployment deploymentdemo deploymentdemo=nginx:1.18.0-alpine</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过属性修改达到升级nginx镜像版本为1.19.2-alpine，与上面的命令二选一即可</span></span><br><span class="line">kubectl edit deployments.apps deploymentdemo</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod升级情况</span></span><br><span class="line">kubectl get pods -w</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进去某一个pod内部，查看nginx升级版本信息</span></span><br><span class="line">kubectl exec -it deploymentdemo1-df6bc5d4c-flc7b sh</span><br><span class="line">nginx -v</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h3 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h3><p>部署更新相关，可以参考<a href="../../09/deploy-desc">关于蓝绿发布、灰度以及滚动发布的记录</a></p><h4 id="金丝雀发布"><a href="#金丝雀发布" class="headerlink" title="金丝雀发布"></a>金丝雀发布</h4><p>&emsp;&emsp;Deployment控制器支持自定义控制更新过程中的滚动节奏，如“暂停(pause)”或“继续(resume)”更新操作。比如等待第一批新的Pod资源创建完成后立即暂停更新过程，此时，仅存在一部分新版本的应用，主体部分还是旧的版本。然后，再筛选一小部分的用户请求路由到新版本的Pod应用，继续观察能否稳定地按期望的方式运行。确定没问题之后再继续完成余下的Pod资源滚动更新，否则立即回滚更新操作。这就是所谓的金丝雀发布（Canary Release）</p><p>滚动更新命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新deployment的nginx:1.18.0-alpine版本，并配置暂停deployment</span></span><br><span class="line">kubectl set image deployment deploymentdemo1 deploymentdemo1=nginx:1.18.0-</span><br><span class="line">alpine &amp;&amp; kubectl rollout pause deployment deploymentdemo1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 观察更新状态</span></span><br><span class="line">kubectl rollout status deployment deploymentdemo1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 监控更新的过程，可以看到已经新增了一个资源，但是并未按照预期的状态去删除一个旧的资源，就是因为使用了pause暂停命令</span></span><br><span class="line">kubectl get pods -l app=deploymentdemo1 -w</span><br><span class="line"><span class="meta">#</span><span class="bash"> 确保更新的pod没问题了，继续更新</span></span><br><span class="line">kubectl rollout resume deploy deploymentdemo1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看最后的更新情况</span></span><br><span class="line">kubectl get pods -l app=deploymentdemo1 -w</span><br></pre></td></tr></table></figure><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>&emsp;&emsp;默认情况下，kubernetes 会在系统中保存前两次的 Deployment 的 rollout 历史记录，以便可以随时回退（您可以修改revision history limit 来更改保存的revision数）。</p><blockquote><p>注意： 只要 Deployment 的 rollout 被触发就会创建一个 revision。也就是说当且仅当Deployment 的 Pod template（如.spec.template ）被更改，例如更新template 中的 label 和容器镜像时，就会创建出一个新的 revision。<br>其他的更新，比如扩容 Deployment 不会创建 revision——因此我们可以很方便的手动或者自动扩容。这意味着当您回退到历史 revision 时，只有 Deployment 中的 Pod template 部分才会回退。</p></blockquote><h4 id="rollout常见命令"><a href="#rollout常见命令" class="headerlink" title="rollout常见命令"></a>rollout常见命令</h4><table><thead><tr><th align="left">子命令</th><th align="left">功能说明</th></tr></thead><tbody><tr><td align="left">history</td><td align="left">查看rollout操作历史</td></tr><tr><td align="left">pause</td><td align="left">将提供的资源设定为暂停状态</td></tr><tr><td align="left">restart</td><td align="left">重启某资源</td></tr><tr><td align="left">resume</td><td align="left">将某资源从暂停状态恢复正常</td></tr><tr><td align="left">status</td><td align="left">查看rollout操作状态</td></tr><tr><td align="left">undo</td><td align="left">回滚前一rollout</td></tr></tbody></table><p>具体命令示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout history deployment deploymentdemo</span><br><span class="line"></span><br><span class="line">kubectl rollout status deployment deploymentdemo</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 回滚版本信息</span></span><br><span class="line">kubectl rollout undo deployment deploymentdemo1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看pod回滚情况</span></span><br><span class="line">kubectl get pods -w</span><br></pre></td></tr></table></figure><h3 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h3><p>&emsp;&emsp;Deployment 可以保证在升级时只有一定数量的 Pod 是 down 的。默认的，它会确保至少有比期望的Pod数量少一个是up状态（最多一个不可用）<br>&emsp;&emsp;Deployment 同时也可以确保只创建出超过期望数量的一定数量的 Pod。默认的，它会确保最多比期望的Pod数量多一个的 Pod 是 up 的（最多1个 surge ）</p><blockquote><p>Kuberentes 版本v1.17.5中，从1-1变成25%-25%</p></blockquote><p>查看命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe deployments.apps deploymentdemo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看到属性：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> RollingUpdateStrategy: 25% max unavailable, 25% max surge</span></span><br></pre></td></tr></table></figure><h2 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h2><p>&emsp;&emsp;DaemonSet 确保全部Node 上运行一个 Pod 的副本。当有 Node 加入集群时，也会为他们新增一个 Pod 。当有 Node 从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有Pod。<br>&emsp;&emsp;在每一个node节点上只调度一个Pod，因此无需指定replicas的个数，比如：</p><ul><li>在每个node上都运行一个日志采集程序，负责收集node节点本身和node节点之上的各个Pod所产生的日志</li><li>在每个node上都运行一个性能监控程序，采集该node的运行性能数据</li></ul><p><img src="/2022/02/08/k8s-controller/daemonset.png" alt="daemonset.png"></p><p>DaemonSet 控制器是如何保证每个 Node 上有且只有一个被管理的 Pod 呢？</p><ul><li>首先控制器从 Etcd 获取到所有的 Node 列表，然后遍历所有的 Node。</li><li>根据资源对象定义是否有调度相关的配置，然后分别检查 Node 是否符合要求。</li><li>在可运行 Pod 的节点上检查是否已有对应的 Pod，如果没有，则在这个 Node 上创建该 Pod；如果有，并且数量大于 1，那就把多余的 Pod 从这个节点上删除；如果有且只有一个 Pod，那就说明是正常情况。</li></ul><p>DaemonSet有两种更新策略类型：</p><ul><li>OnDelete：这是向后兼容性的默认更新策略。使用 OnDelete 更新策略，在更新DaemonSet模板后，只有在手动删除旧的DaemonSet pod时才会创建新的DaemonSet pod。这与Kubernetes 1.5或更早版本中DaemonSet的行为相同。</li><li>RollingUpdate：使用RollingUpdate 更新策略，在更新DaemonSet模板后，旧的DaemonSet pod将被终止，并且将以受控方式自动创建新的DaemonSet pod。</li></ul><h2 id="Job与CronJob"><a href="#Job与CronJob" class="headerlink" title="Job与CronJob"></a>Job与CronJob</h2><p>&emsp;&emsp;Job 负责处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个 Pod 成功结束。而<code>CronJob</code> 则就是在 Job 上加上了时间调度。<br>Job特点：</p><ul><li>一次性执行任务，类似Linux中的job</li><li>应用场景：如离线数据处理，视频解码等业务</li></ul><p>模板示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pi</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">perl:slim</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;perl&quot;</span>, <span class="string">&quot;-Mbignum=bpi&quot;</span>, <span class="string">&quot;-wle&quot;</span>, <span class="string">&quot;print bpi(6000)&quot;</span>]</span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>通过模板可知，Job 中也是一个 Pod 模板，和之前的 Deployment、StatefulSet 之类的是一致的，只是 Pod 中的容器要求是一个任务，而不是一个常驻前台的进程了，因为它是需要退出的。<br>另外值得注意的是 Job 的 RestartPolicy 仅支持 Never 和 OnFailure 两种，不支持 Always，由于 Job 就相当于来执行一个批处理任务，执行完就结束了，如果 Always 的话就陷入了死循环了。</p><h3 id="backoffLimit说明"><a href="#backoffLimit说明" class="headerlink" title="backoffLimit说明"></a>backoffLimit说明</h3><p><code>.spec.backoffLimit</code>用于设置Job的容错次数，默认值为6。当Job运行的Pod失败次数到达<code>.spec.backoffLimit</code>次时，Job Controller不再新建Pod，直接停止运行这个Job，将其运行结果标记为<code>Failure</code>。另外，Pod运行失败后再次运行的时间间隔呈递增状态，例如10s，20s，40s。。。</p><h3 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h3><p>资源文件中Kind 变成了<code>CronJob</code> 了，要注意的是<code>.spec.schedule</code>字段是必须填写的，用来指定任务运行的周期，格式就和 <code>crontab</code> 一样，另外一个字段是<code>.spec.jobTemplate</code>, 用来指定需要运行的任务，格式当然和 <code>Job</code> 是一致的。</p><p><code>.spec.successfulJobsHistoryLimit</code> 和 <code>.spec.failedJobsHistoryLimit</code>，表示历史限制，是可选的字段，指定可以保留多少完成和失败的 Job，默认没有限制，所有成功和失败的 Job 都会被保留。</p><h2 id="StatefullSet"><a href="#StatefullSet" class="headerlink" title="StatefullSet"></a>StatefullSet</h2><p>&emsp;&emsp;在kubernetes系统中，Pod的管理对象RC，Deployment，DaemonSet和Job都面向无状态的服务，但现实中有很多服务时有状态的，比如一些集群服务，例如mysql集群，集群一般都会有这四个特点：</p><ol><li>每个节点都是有固定的身份ID，集群中的成员可以相互发现并通信</li><li>集群的规模是比较固定的，集群规模不能随意变动</li><li>集群中的每个节点都是有状态的，通常会持久化数据到永久存储中</li><li>如果磁盘损坏，则集群里的某个节点无法正常运行，集群功能受损</li></ol><p>&emsp;&emsp;如果通过RC或Deployment控制Pod副本数量来实现上述有状态的集群，就会发现第一点是无法满足的，因为Pod名称和ip是随机产生的，并且各Pod中的共享存储中的数据不能都动，因此StatefulSet在这种情况下就派上用场了，那么StatefulSet具有以下特性：</p><ul><li>StatefulSet里的每个Pod都有稳定，唯一的网络标识，可以用来发现集群内的其它成员，假设， StatefulSet的名称为lagou，那么第1个Pod叫lagou-0，第2个叫lagou-1，以此类推</li><li>StatefulSet控制的Pod副本的启停顺序是受控的，操作第N个Pod时，前N-1个Pod已经是运行且准备状态</li><li>StatefulSet里的Pod采用稳定的持久化存储卷，通过PV或PVC来实现，删除Pod时默认不会删除与 StatefulSet相关的存储卷（为了保证数据的安全）</li></ul><p>StatefulSet除了要与PV卷捆绑使用以存储Pod的状态数据，还要与Headless，Service配合使用，每个StatefulSet定义中都要生命它属于哪个Handless Service，Handless Service与普通Service的关键区别在于，它没有Cluster IP</p>]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> kubernetes </tag>
            
            <tag> 容器 </tag>
            
            <tag> controller </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s中pod生命周期详解</title>
      <link href="/2022/02/08/k8s-pod-life/"/>
      <url>/2022/02/08/k8s-pod-life/</url>
      
        <content type="html"><![CDATA[<h2 id="Pod阶段"><a href="#Pod阶段" class="headerlink" title="Pod阶段"></a>Pod阶段</h2><p>&emsp;&emsp;使用<code>kubectl get pods</code>命令获取到的结果中，<code>STATUS</code>被称之为<code>phase</code>(个人理解为阶段，不过网上很多翻译为相位，相位的解释跟波有关，可自行百度)。<br>&emsp;&emsp;当然也可以通过<code>kubectl explain pod.status</code>命令来查看Pod状态的枚举值，Pod的状态定义在 PodStatus 对象中，其中有一个<code>phase</code>字段。<br>&emsp;&emsp;无论是手动创建还是通过控制器创建Pod，Pod对象总是应该处于其生命进程中以下几个阶段<code>phase</code>之一：</p><ul><li>挂起（Pending）：<code>apiserver</code>创建了pod资源对象并存入etcd中，但是还没有被调度器调度到合适的节点或者镜像正在下载中；</li><li>运行中（Running）：Pod已经被调度至某节点，并且所有容器都已经被<code>kubelet</code>创建完成。至少有一个容器正在运行，或者正处于启动或重启状态；</li><li>成功（Succeeded）：Pod中的所有容器都被成功终止，并且不会再重启；</li><li>失败（Failed）：Pod中的所有容器都已终止了，但至少有一个容器是因为终止失败，容器以非0状态退出或者被系统终止；</li><li>未知（Unknown）：因为某些原因<code>apiserver</code>无法正常获取到Pod对象的状态信息，通常是因为与Pod所在节点通信失败导致的；</li></ul><p>Pod在生命周期中状态的变化如下图：<br><img src="/2022/02/08/k8s-pod-life/pod-status.png" alt="pod-phase.png"></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="/2022/02/08/k8s-pod-life/pod-life.png" alt="pod.png"><br>&emsp;&emsp;Pod的生命周期如图所示，具体解释如下：</p><h3 id="initContainer"><a href="#initContainer" class="headerlink" title="initContainer"></a>initContainer</h3><p>&emsp;&emsp;Init Container就是用来做初始化工作的容器，可以是一个或者多个，如果有多个的话，这些容器会按定义的顺序依次执行，只有所有的`初始化容器执行完之后，主容器才会被启动。<br>&emsp;&emsp;特点如下：</p><ol><li>initC总是运行到成功完成为止。</li><li>每个initC容器都必须在下一个initC启动之前成功完成。</li><li>如果initC容器运行失败，K8S集群会不断的重启该pod，直到initC容器成功为止。</li><li>如果pod对应的restartPolicy为never，它就不会重新启动。</li></ol><p>&emsp;&emsp;其对应在资源清单yaml文件中，就是<code>spec</code>中<code>initContainers</code>配置。</p><p>&emsp;&emsp;初始化容器的应用场景：</p><ul><li>等待其他模块 Ready：解决服务之间的依赖问题，比如Web 服务依赖于数据库服务，但是在启动这个 Web 服务的时候并不能保证数据库服务已经就绪，就可能会出现一段时间内 Web 服务连接数据库异常。要解决这个问题的话，就可以在 Web 服务的 Pod 中使用一个 InitContainer，去检查数据库是否已经准备好了，检查成功后Web 服务才被启动起来，这个时候去连接数据库就不会有问题了。</li><li>做初始化配置：比如集群里检测所有已经存在的成员节点，为主容器准备好集群的配置信息，这样主容器起来后就能用这个配置信息加入集群。</li><li>其它场景：如将 Pod 注册到一个中央数据库、配置中心等。</li></ul><h3 id="mainContainer"><a href="#mainContainer" class="headerlink" title="mainContainer"></a>mainContainer</h3><p>&emsp;&emsp;当initC都成功完成之后，就会进行主容器的创建，例如上面的例子，web服务就是主容器。</p><h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><p>&emsp;&emsp;监控检查分为两类：</p><ul><li>readinessProbe(就绪检测)：检测容器是否准备好服务请求，只有当Pod中的容器都处于就绪状态的时候，kubelet才会认定该Pod处于就绪状态。如果就绪探测失败，端点控制器将从与Pod匹配的所有Service的端点中删除该Pod的IP地址。初始延迟之前的就绪状态默认为Failure。如果容器不提供就绪探针，则默认状态为Success。</li><li>livenessProbe(存活检测)：检测容器是否正在运行。如果存活探测失败，则kubelet会杀死容器，并且容器将受到其<code>重启策略</code>的影响。如果容器不提供存活探针，则默认状态为Success。</li></ul><p>&emsp;&emsp;其探测的方法有以下三种：</p><ul><li>ExecAction：在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。</li><li>TCPSocketAction：对指定端口上的容器的 IP 地址进行 TCP 检查。如果端口打开，则诊断被认为是成功的。</li><li>HTTPGetAction：对指定的端口和路径上的容器的 IP 地址执行 HTTP Get 请求。如果响应的状态码大于等于200 且小于 400，则诊断被认为是成功的。</li></ul><p>任何一种探测方式都可能存在三种结果：</p><ul><li>success(成功)：容器通过了诊断；</li><li>failure(失败)：容器未通过了诊断；</li><li>unknown(未知)：诊断失败，因此不会采取任何行动；</li></ul><p>具体配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exec方式</span></span><br><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">exec:</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cat</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">/app/healthz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># httpGet方式</span></span><br><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/app/healthz</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># socket方式</span></span><br><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">tcpSocket:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>一般就绪探针会在启动Pod一段时间后才开始第一次的就绪探测，之后做周期性探测。参数如下：</p><ul><li>initialDelaySeconds：在初始化容器多少秒后开始第一次就绪探测；</li><li>timeoutSeconds：如果该次就绪探测超过多少秒后还未成功，判定为超时，该次探测失败，Pod不就绪。默认值1，最小值1；</li><li>periodSeconds：如果Pod未就绪，则每隔多少秒周期性的做就绪探测。默认值10，最小值1；</li><li>failureThreshold：如果容器之前探测成功，后续连续几次探测失败，则确定容器未就绪。默认值3，最小值1；</li><li>successThreshold：如果容器之前探测失败，后续连续几次探测成功，则确定容器就绪。默认值1，最小值1。</li></ul><h3 id="Pod-Hook"><a href="#Pod-Hook" class="headerlink" title="Pod Hook"></a>Pod Hook</h3><p>&emsp;&emsp;K8s提供了生命周期的钩子<code>Pod Hook</code>，Pod Hook 是由 kubelet 发起的，当容器中的进程启动前或者终止之前运行。</p><ul><li>PostStart： 于容器创建完成之后立即运行的钩子处理器（handler），不过k8s无法确保它一定会于容器中的entrypoint之前运行；</li><li>PreStop：于容器终止操作之前立即运行的钩子处理器，它以同步的方式调用，因此在其完成之前会阻塞删除容器的操作调用；</li></ul><h2 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h2><p>以下为一个pod资源对象的典型创建过程：</p><ol><li>用户通过kubectl或其他api客户端提交pod spec给api server；</li><li>api server尝试着将pod对象的相关信息存入etcd中，待写入操作执行完成，api server即会返回确认信息至客户端；</li><li>api server开始反映etcd中的状态变化；</li><li>所有的k8s组件均使用watch机制来跟踪检查api server上的相关变动；</li><li>kube-scheduler通过其watch觉察到api server创建了新的pod对象但尚未绑定至任何工作节点；</li><li>kube-scheduler为pod对象挑选一个工作节点并将结果信息更新至api server；</li><li>调度结果信息由api server更新至etcd，而且api server也开始反映此pod对象的调度结果；</li><li>pod被调度到目标工作节点上的kubelet尝试在当前节点上调用docker启动容器，并将容器的结果状态回送至api server；</li><li>api server将pod状态信息存入etcd中；</li><li>在etcd确认写入操作成功完成后，api server将确认信息发送至相关的kubelet；</li></ol><p><img src="/2022/02/08/k8s-pod-life/pod-create.png" alt="pod-create.png"></p><h2 id="重启策略"><a href="#重启策略" class="headerlink" title="重启策略"></a>重启策略</h2><p>&emsp;&emsp;容器程序发生奔溃或容器申请超出限制的资源等原因都可能会导致pod对象的终止，此时是否应该重建该pod对象则取决于其重启策略（restartPolicy）属性的定义：</p><ul><li>Always：但凡pod对象终止就将其重启，此为默认设定</li><li>OnFailure：尽在pod对象出现错误时方才将其重启</li><li>Never：从不重启。</li></ul><p>&emsp;&emsp;restartPolicy适用于pod对象中的所有容器，而且它仅用于控制在同一节点上重新启动pod对象的相关容器。首次需要重启的容器，将在其需要时立即进行重启，随后再次需要重启的操作将由kubelet延迟一段时间后进行，且反复的重启操作的延迟时长以此为10s、20s、40s、80s、160s和300s，300s是最大延迟时长，上限为 5 分钟，并在成功执行 10 分钟后重置。<br>&emsp;&emsp;事实上，一旦绑定到一个节点，pod对象将永远不会重新绑定到另一个节点，它要么被重启，要么终止，直到节点发生故障或被删除。</p><p>不同类型的的控制器可以控制 Pod 的重启策略：</p><ul><li>Job：适用于一次性任务如批量计算，任务结束后 Pod 会被此类控制器清除。Job 的重启策略只能是”OnFailure”或者”Never”。</li><li>Replication Controller, ReplicaSet, or Deployment，此类控制器希望 Pod 一直运行下去，它们的重启策略只能是”Always”。</li><li>DaemonSet：每个节点上启动一个 Pod，很明显此类控制器的重启策略也应该是”Always”。</li></ul><h2 id="终止过程"><a href="#终止过程" class="headerlink" title="终止过程"></a>终止过程</h2><p>&emsp;&emsp;当用户提交删除请求之后，系统就会进行强制删除操作的宽限期倒计时，并将TERM信息发送给pod对象的每个容器中的主进程。宽限期倒计时结束后，这些进程将收到强制终止的KILL信号，pod对象随即也将由api server删除，如果在等待进程终止的过程中，kubelet或容器管理器发生了重启，那么终止操作会重新获得一个满额的删除宽限期并重新执行删除操作。<br>一个典型的pod对象终止流程具体如下：</p><ol><li>用户发送删除pod对象的命令；</li><li>api服务器中的pod对象会随着时间的推移而更新，在宽限期内（默认30s），pod被视为dead；</li><li>将pod标记为terminating状态；</li><li>与第三步同时运行，kubelet在监控到pod对象转为terminating状态的同时启动pod关闭过程；</li><li>与第三步同时运行，端点控制器监控到pod对象的关闭行为时将其从所有匹配到此端点的service资源的端点列表中移除；</li><li>如果当前pod对象定义了preStop钩子处理器，则在其标记为terminating后即会以同步的方式启动执行；若宽限期结束后，preStop仍未执行结束，则第二步会被重新执行并额外获取一个时长为2s的小宽限期；</li><li>pod对象中的容器进程收到TERM信号；</li><li>宽限期结束后，若存在任何一个仍在运行的进程，那么pod对象即会收到SIGKILL信号；</li><li>kubelet请求api server将此pod资源的宽限期设置为0从而完成删除操作，它变得对用户不再可见；</li></ol><p>默认情况下，所有删除操作的宽限期都是30s，不过，kubectl delete命令可以使用“–grace-period=”选项自定义其时长，若使用0值则表示直接强制删除指定的资源，不过此时需要同时使用命令“–forece”选项。</p>]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> kubernetes </tag>
            
            <tag> pod </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s中pod简介</title>
      <link href="/2022/02/07/k8s-pod/"/>
      <url>/2022/02/07/k8s-pod/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;Pod是kubernetes集群能够调度的最小单元，Pod是容器的封装，这些容器共享存储、网络和命名空间，以及如何运行的规范。在Pod中，所有容器都被同一安排和调度，并运行在共享的上下文中。对于具体应用而言，Pod是它们的逻辑主机，Pod包含业务相关的多个应用容器。<br><img src="/2022/02/07/k8s-pod/pods.png" alt="pods.png"></p><h3 id="为什么不直接调度container"><a href="#为什么不直接调度container" class="headerlink" title="为什么不直接调度container"></a>为什么不直接调度container</h3><p>&emsp;&emsp;如果调度的基本单元就是容器，对于一个非常简单的应用可以直接被调度使用，没有什么问题，但是实际的很多应用程序是由多个进程组成的，如果都部署到一个容器中，由于Docker管理的进程是<code>pid=1</code>的主进程，其他进程没办法进行管理了，而且一个容器最好只干一件事情，所以在真实的环境中不会使用这种方式。<br>&emsp;&emsp;如果将程序拆分成很多容器进行部署，就可能出现一个应用下面的关联的容器被调度到了不同的节点上，无法实现本地通信。<br>&emsp;&emsp;所以通过Pod将这些容器绑定在一起，并将他们作为一个整体进行管理，这样就可以保证这些容器始终在同一个节点上面，这也就是Pod设计的初衷。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>&emsp;&emsp;在同一个Pod中的容器是共用了存储、网络和命名空间的，具体实现原理如图：<br><img src="/2022/02/07/k8s-pod/pod.png" alt="pod.png"></p><p>&emsp;&emsp;对于容器来说，两个或多个容器想要共用一个网络，需要在启动时增加参数<code>--net=container:目标容器名</code>，实现网络共享。这个参数表示要和哪个容器共享网络，缺点是这个目标容器必须先启动。<br>&emsp;&emsp;Pod也是通过这种方式实现的共享，在Pod创建时第一个创建的容器就是<code>Pause容器</code>（因为使用的镜像是pause），全称 infrastucture container，所以也叫<code>Infra 容器</code>。Pod中其他容器只需要在启动时指定使用<code>Infra容器</code>的网络即可实现共享，多个容器之间可以通过<code>localhost</code>进行访问，需要注意<code>端口号不能冲突</code>。<br>&emsp;&emsp;默认情况下容器的文件系统是互相隔离的，要实现共享只需要在<code>Pod</code>的顶层声明一个<code>Volume</code>，然后在需要共享这个<code>Volume</code>的容器中声明挂载即可。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>GET命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看集群状态信息</span></span><br><span class="line">kubectl cluster-info</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集群状态</span></span><br><span class="line">kubectl get cs</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集群节点信息</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集群命名空间</span></span><br><span class="line">kubectl get ns</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看指定命名空间的服务</span></span><br><span class="line">kubectl get svc -n kube-system</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以纯文本输出格式列出所有 pod。</span></span><br><span class="line">kubectl get pods</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以纯文本输出格式列出所有 pod，并包含附加信息(如节点名)。</span></span><br><span class="line">kubectl get pods -o wide</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以纯文本输出格式列出具有指定名称的副本控制器。提示：您可以使用别名 <span class="string">&#x27;rc&#x27;</span> 缩短和替换<span class="string">&#x27;replicationcontroller&#x27;</span> 资源类型。</span></span><br><span class="line">kubectl get replicationcontroller &lt;rc-name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以纯文本输出格式列出所有副本控制器和服务。</span></span><br><span class="line">kubectl get rc,services</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以纯文本输出格式列出所有守护程序集，包括未初始化的守护程序集。</span></span><br><span class="line">kubectl get ds --include-uninitialized</span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出在节点 server01 上运行的所有 pod</span></span><br><span class="line">kubectl get pods --field-selector=spec.32 nodeName=server01</span><br></pre></td></tr></table></figure><p>describe命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示名称为 &lt;node-name&gt; 的节点的详细信息。</span></span><br><span class="line">kubectl describe nodes &lt;node-name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示名为 &lt;pod-name&gt; 的 pod 的详细信息。</span></span><br><span class="line">kubectl describe pods/&lt;pod-name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示由名为 &lt;rc-name&gt; 的副本控制器管理的所有 pod 的详细信息。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 记住：副本控制器创建的任何 pod 都以复制控制器的名称为前缀。</span></span><br><span class="line">kubectl describe pods &lt;rc-name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 描述所有的 pod，不包括未初始化的 pod</span></span><br><span class="line">kubectl describe pods --include-uninitialized=false</span><br></pre></td></tr></table></figure><p>delete命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 pod.yaml 文件中指定的类型和名称删除 pod。</span></span><br><span class="line">kubectl delete -f pod.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除标签名= &lt;label-name&gt; 的所有 pod 和服务。</span></span><br><span class="line">kubectl delete pods,services -l name=&lt;label-name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有具有标签名称= &lt;label-name&gt; 的 pod 和服务，包括未初始化的那些。</span></span><br><span class="line">kubectl delete pods,services -l name=&lt;label-name&gt; --include-uninitialized</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有 pod，包括未初始化的 pod。</span></span><br><span class="line">kubectl delete pods --all</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制删除一个pod</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --force --grace-period=0</span></span><br></pre></td></tr></table></figure><p>进入容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从 pod &lt;pod-name&gt; 中获取运行 <span class="string">&#x27;date&#x27;</span> 的输出。默认情况下，输出来自第一个容器。</span></span><br><span class="line">kubectl exec &lt;pod-name&gt; date</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行输出 <span class="string">&#x27;date&#x27;</span> 获取在容器的 &lt;container-name&gt; 中 pod &lt;pod-name&gt; 的输出。</span></span><br><span class="line">kubectl exec &lt;pod-name&gt; -c &lt;container-name&gt; date</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取一个交互 TTY 并运行 /bin/bash &lt;pod-name &gt;。默认情况下，输出来自第一个容器。</span></span><br><span class="line">kubectl exec -ti &lt;pod-name&gt; /bin/bash</span><br></pre></td></tr></table></figure><p>日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从 pod 返回日志快照。</span></span><br><span class="line">kubectl logs &lt;pod-name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从 pod &lt;pod-name&gt; 开始流式传输日志。这类似于 <span class="string">&#x27;tail -f&#x27;</span> Linux 命令。</span></span><br><span class="line">kubectl logs -f &lt;pod-name&gt;</span><br></pre></td></tr></table></figure><p>格式化输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将pod信息格式化输出到一个yaml文件</span></span><br><span class="line">kubectl get pod web-pod-13je7 -o yaml</span><br></pre></td></tr></table></figure><p>获取帮助文档：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl explain pod</span><br></pre></td></tr></table></figure><h2 id="资源清单"><a href="#资源清单" class="headerlink" title="资源清单"></a>资源清单</h2><p>&emsp;&emsp;资源清单就是一个符合k8s要求的yaml配置文件，用于生成各种K8s资源。<br>Pod的yaml格式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">group/apiversion</span> <span class="comment"># 默认为 v1，可以使用 kubectl apiversions 获取当前 k8s 版本上所有的 apiVersion 版本信息</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span> <span class="comment">#资源类别,Pod、Deployment、ConfigMap、Service等</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment">#资源元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">xx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">xx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">annotations:</span>  <span class="comment"># 主要目的是方便用户阅读查找</span></span><br><span class="line">    <span class="attr">xx:</span> <span class="string">xx</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 期望的状态（disired state）</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">xx</span> </span><br><span class="line">      <span class="attr">image:</span> <span class="string">xx</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span>  <span class="comment"># 镜像下载策略</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>,<span class="string">&#x27;-c&#x27;</span>,<span class="string">&#x27;echo test&#x27;</span>]</span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">readinessProbe:</span>   <span class="comment"># 就绪监测</span></span><br><span class="line">        <span class="attr">httpGet:</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/index1.html</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">livenessProbe:</span>   <span class="comment"># 存活检测</span></span><br><span class="line">        <span class="attr">exec:</span>    <span class="comment"># 命令方式</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;test&quot;</span>,<span class="string">&quot;-e&quot;</span>,<span class="string">&quot;/tmp/livenesspod&quot;</span>]</span><br><span class="line">          </span><br><span class="line">        <span class="attr">httpGet:</span>  <span class="comment"># http请求方式</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/index.html</span></span><br><span class="line">          </span><br><span class="line">        <span class="attr">tcpSocket:</span>  <span class="comment"># 端口检测方式</span></span><br><span class="line">            <span class="comment">#监测8080端口，如果8080端口没有反馈信息，重启pod</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">            </span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">periodSeconds:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">lifecycle:</span>   <span class="comment"># 钩子回调方法</span></span><br><span class="line">        <span class="attr">postStart:</span>  <span class="comment"># 启动前先执行</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span> [<span class="string">&#x27;mkdir&#x27;</span>,<span class="string">&#x27;-p&#x27;</span>,<span class="string">&#x27;/var/k8s/index.html&#x27;</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="attr">preStop:</span>  <span class="comment"># 删除钱执行</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span> [<span class="string">&#x27;rm&#x27;</span>,<span class="string">&#x27;-f&#x27;</span>,<span class="string">&#x27;/var/k8s/index.html&#x27;</span>]</span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span>   <span class="comment"># 重启策略</span></span><br><span class="line">  <span class="attr">initContainers:</span>   <span class="comment"># initC</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">status:</span> <span class="comment"># 当前状态，本字段有 Kubernetes 自身维护，用户不能去定义</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> kubernetes </tag>
            
            <tag> pod </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全组与防火墙</title>
      <link href="/2022/01/26/sg-firewall/"/>
      <url>/2022/01/26/sg-firewall/</url>
      
        <content type="html"><![CDATA[<h2 id="安全组与防火墙的区别"><a href="#安全组与防火墙的区别" class="headerlink" title="安全组与防火墙的区别"></a>安全组与防火墙的区别</h2><p>很多人分不清楚OpenStack中安全组(security group)和防火墙(firewall)的区别，因为二者都是做网络访问控制的，并且都是基于iptables实现的。</p><p>其实二者的区别还是比较大的:</p><ul><li>security group主要是做主机防护的，换句话说安全组是和虚拟机的port相关联，安全组是针对每一个port做网络访问控制，所以它更像是一个主机防火墙。而firewall是针对一个VPC网络的，它针对的是整个VPC的网络控制，通常是在路由做策略。因此security group在计算节点的tap设备上做，而firewall在网络节点的router上做。</li><li>相对于传统网络模型，security group其实就是类似于操作系统内部自己配置的防火墙，而firewall则是旁挂在路由器用于控制整个局域网网络流量的防火墙。</li><li>security group定义的是允许通过的规则集合，即规则的动作就是ACCEPT。换句话说定义的是白名单规则，因此如果虚拟机关联的是一个空规则安全组，则虚拟机既出不去也进不来。并且由于都是白名单规则，因此安全组规则顺序是无所谓的，而且一个虚拟机port可以同时关联多个安全组，此时相当于规则集合的并集。而firewall规则是有动作的（allow,deny,reject），由于规则既可以是ACCEPT，也可以是DROP，因此先后顺序则非常重要，一个包的命运，不仅取决于规则，还取决于规则的优先级顺序。</li><li>前面说到security group针对的是虚拟机port，因为虚拟机的IP是已知条件，定义规则时不需要指定虚拟机IP，比如定义入访规则时，只需要定义源IP、目标端口、协议，不需要定义目标IP。而防火墙针对的是整个二层网络，一个二层网络肯定会有很多虚拟机，因此规则需要同时定义源IP、源端口、目标IP、目标端口、协议。</li><li>security group通常用于实现东西向流量控制实现微分段策略，而firewall则通常用于实现南北向流量控制。</li><li>安全组由L2 Agent来实现，比如neutron-openvswitch-agent和neutron-linuxbridge-agent，会将安全组规则转换成IPTables规则，而且一般发生在所有计算节点上。防火墙由L3 Agent来实现，它的规则会在租户的Router所在的L3 Agent节点上转化成IPTables规则。</li><li>防火墙保护只能作用于跨网段的网络流量，而安全组则可以作用于任何进出虚拟机的流量。</li><li>防火墙作为高级网络服务，将被用于服务链中,而安全组则不能。</li></ul><p>在Neutron中同时部署防火墙和安全组可以达到双重防护。</p><p>外部恶意访问可以被防火墙过滤掉,避免了计算节点的安全组去处理恶意访问所造成的资源损失。</p><p>即使防火墙被突破,安全组作为下一到防线还可以保护虚拟机。</p><p>最重要的是，安全组可以过滤掉来自内部的恶意访问。</p><p>后续补充……</p>]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenStack </tag>
            
            <tag> 安全组 </tag>
            
            <tag> 防火墙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenStack负载均衡Octavia简介</title>
      <link href="/2022/01/26/octavia/"/>
      <url>/2022/01/26/octavia/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h3><p>负载均衡，英文名称为Load Balance，其含义就是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如FTP服务器、Web服务器、企业核心应用服务器和其它主要任务服务器等，从而协同完成工作任务。</p><h3 id="负载均衡的作用"><a href="#负载均衡的作用" class="headerlink" title="负载均衡的作用"></a>负载均衡的作用</h3><p>对多台服务器进行流量分发的服务。负载均衡可以通过流量分发扩展应用系统对外的服务能力，通过消除单点故障提升应用系统的可用性。</p><ol><li>提高可用性和访问速度<br>在单个可用区或多个可用区内的多个目标之间自动分配流量。</li><li>运行状况检查<br>检测无法正常运行的目标、停止向它们发送流量，然后将负载分散到剩余的正常运行的目标上。</li><li>安全性功能<br>创建和管理与负载均衡器关联的安全组，以提供更多联网和安全选项。</li><li>TLS 终止<br>提供集成化证书管理和 SSL/TLS 解密，可以灵活地集中管理负载均衡器的 SSL 设置，并从应用程序上卸载 CPU 密集型工作。</li></ol><h3 id="负载均衡分类"><a href="#负载均衡分类" class="headerlink" title="负载均衡分类"></a>负载均衡分类</h3><ol><li>软负载均衡<ul><li>软件实现负载均衡</li></ul></li><li>硬负载均衡<ul><li>硬件设备</li></ul></li><li>四层/七层负载均衡<ul><li>二层的就是基于MAC地址，二层负载均衡会通过一个虚拟MAC地址接受请求，然后再分配到真实的MAC地址。</li><li>三层负载就是通过一个虚拟IP地址，然后再分配到真实的IP。</li><li>四层就是通过虚机的IP+端口接收请求，然后再分配到真实的服务器；</li><li>七层就是通过虚机主机名或者URL接收请求，再根据一些规则分配到真实的服务器，常见的应用是nginx。</li></ul></li><li>ALB：Application Load Balancer 运行于请求级别（第 7 层），可根据请求的内容将流量路由至 EC2 实例、容器、IP 地址和 Lambda 函数等目标。Application Load Balancer 最适合 HTTP 和 HTTPS 流量的高级负载均衡，面向交付包括微服务和基于容器的应用程序在内的现代应用程序架构，提供高级请求路由功能。Application Load Balancer 通过确保始终使用最新的 SSL/TLS 密码和协议，简化并提高应用程序的安全性。</li><li>NLB：Network Load Balancer 网络负载均衡器运行于连接级别（第 4 层），可根据 IP 协议数据将连接路由至 Amazon Virtual Private Cloud (Amazon VPC) 内的不同目标（Amazon EC2 实例、微服务和容器）。网络负载均衡器最适合 TCP 流量的负载均衡，能够在保持超低延迟的同时每秒处理数百万个请求。网络负载均衡器还经过了优化，能够处理突发的和不稳定的流量模式，同时在每个可用区使用单个静态 IP 地址。它与其他流行的 AWS 服务集成，例如 Auto Scaling、Amazon EC2 Container Service (ECS)、Amazon CloudFormation 和 Amazon AWS Certificate Manager (ACM)。</li></ol><h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><p><strong>1、轮询法</strong></p><p>将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</p><p><strong>2、随机法</strong></p><p>​        通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。</p><p><strong>3、源地址哈希法</strong></p><p>​        源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</p><p><strong>4、加权轮询法</strong></p><p>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p><p><strong>5、加权随机法</strong></p><p>​        与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</p><p><strong>6、最小连接数法</strong></p><p>​        最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</p><h3 id="常用负载均衡比较"><a href="#常用负载均衡比较" class="headerlink" title="常用负载均衡比较"></a>常用负载均衡比较</h3><table><thead><tr><th><strong>比较</strong></th><th><strong>HAProxy</strong></th><th><strong>Nginx</strong></th><th><strong>LVS</strong></th></tr></thead><tbody><tr><td><strong>优点</strong></td><td><strong>支持session保持，Cookie引导</strong>。  可通过url检测后端服务器健康状态。  也可做MySQL、Email等负载均衡。  支持通过指定的URL对后端服务器健康检查。</td><td>http、https、Emai协议功能较好，处理相应请求快。  Web能力强，配置简单，<strong>支持缓存功能</strong>、适用动静分离，低内存消耗。  <strong>支持WebSocket协议</strong>。  <strong>支持强大的正则匹配规则</strong> 。</td><td>通过vrrp转发（仅分发）效率高，流量通过内核处理，没有流量产生。（理论）  <strong>相当稳定可靠</strong>。</td></tr><tr><td><strong>缺点</strong></td><td>一般不做Web服务器的Cache。</td><td>不支持session直接保持，但可通过ip_hash解决。只能通过端口对后端服务器健康检查。</td><td>不支持正则，不能做动静分离，配置略复杂，需要IP略多。没有后端主机健康状态检查。</td></tr><tr><td><strong>支持算法</strong></td><td>目标uri hash(uri)url参数 (url_params)请求头信息调度(hdr(name))<strong>cookie (rdp-cookie)</strong></td><td>最小响应时间**自定义hash内容(hash key [consistent])**url hash最短时间和最少连接</td><td>最短期望延迟(Shortest Expected Delay)不排队(Never Queue)基于局部性的最少连接(LBLC)带复制的基于局部性最少链接(LCLBR)</td></tr><tr><td><strong>官网</strong></td><td><a href="http://www.haproxy.com/">www.haproxy.com</a></td><td><a href="http://nginx.org/">nginx.org</a></td><td><a href="http://www.linuxvirtualserver.org/">www.linuxvirtualserver.org</a></td></tr><tr><td><strong>虚拟主机</strong></td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td><strong>适用性</strong></td><td>四层，七层（常用）</td><td>四层，七层（常用）</td><td>四层</td></tr><tr><td><strong>量级</strong></td><td>七层重量级，四层轻量级</td><td>七层重量级，四层轻量级</td><td>四层重量级</td></tr><tr><td><strong>常用热备</strong></td><td>Keepalived+其它</td><td>Keepalived+其它</td><td>Keepalived+其它</td></tr></tbody></table><h2 id="OpenStack负载均衡"><a href="#OpenStack负载均衡" class="headerlink" title="OpenStack负载均衡"></a>OpenStack负载均衡</h2><p><strong>Lbaas V1与V2的区别如下：</strong></p><table><thead><tr><th>功能</th><th>lbaas</th><th>lbaasV2</th></tr></thead><tbody><tr><td>最大连接数</td><td>Y</td><td>Y</td></tr><tr><td>TCP负载均衡</td><td>Y</td><td>Y</td></tr><tr><td>HTTP负载均衡</td><td>Y</td><td>Y</td></tr><tr><td>HTTPS负载均衡</td><td>Y</td><td>Y</td></tr><tr><td>TERMINATED_HTTPS负载均衡</td><td>X</td><td>Y</td></tr><tr><td>基于hostname的url转发</td><td>X</td><td>Y</td></tr><tr><td>基于path的url转发</td><td>X</td><td>Y</td></tr><tr><td>基于filename的url转发</td><td>X</td><td>Y</td></tr><tr><td>基于header的url转发</td><td>X</td><td>Y</td></tr><tr><td>基于cookie的url转发</td><td>X</td><td>Y</td></tr><tr><td>一个vip支持多种协议和端口</td><td>X</td><td>Y</td></tr></tbody></table><h2 id="Octavia"><a href="#Octavia" class="headerlink" title="Octavia"></a>Octavia</h2><p>Octavia当前作为OpenStack LbaasV2的一个driver存在，完全兼容lbaasV2的接口，最终的发展趋势会作为一个独立的项目代替lbaasV2。</p><p>根据官网的信息，<code>Octavia brings network load balancing to OpenStack.</code>，Octavia是一个NLB的负载均衡。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Octavia就是将用户的API请求经过逻辑处理，<strong>转换成Haproxy或者Nginx的配置参数</strong>，下发到amphora虚机中。</p><p>Octavia的内部实现中，逻辑流程的处理主要使用TaskFlow库。</p><ul><li><strong>LBaas</strong></li></ul><p>Load Balancing as a Service，在openstack平台上，LB被作为一种服务提供给用户，用户可以按需获取可配置的业务负载分担方案。</p><ul><li><strong>loadbalancer</strong></li></ul><p>负载均衡服务的跟对象，一般为虚机，用户基于此对负载均衡进行配置和操作。</p><ul><li><strong>VIP</strong></li></ul><p>与LB关联的IP地址，作为<strong>外部访问后端服务</strong>的入口。</p><ul><li><strong>Listener</strong></li></ul><p>监听器，用户可通过其配置外部对VIP访问的端口，算法，类型等等。</p><ul><li><strong>Pool</strong></li></ul><p>负责后端的虚拟机池。在Haproxy为driver的情况下，一个Pool对应着一个独立的network namespace中运行的HaProxy进程中管理的backend。</p><p>一个VIP只会有一个Pool。</p><ul><li><strong>Member</strong></li></ul><p>Member 对应的是 pool 里面处理网络请求的一个 OpenStack Nova 虚机。</p><ul><li><strong>Health monitor</strong></li></ul><p>它用来检测pool里面的member的状态，支持很多种检测方法，在neutron里面是可选的。</p><ul><li><strong>L7 Policy</strong></li></ul><p><strong>七层转发策略</strong>，描述数据包转发动作。</p><ul><li><strong>L7 Rule</strong></li></ul><p><strong>七层转发规则</strong>，描述数据包转发的<strong>匹配域</strong>。（匹配<strong>部分</strong>云主机）</p><p><img src="/2022/01/26/octavia/1628496-20190718210436501-155725218.png" alt="forward.png"></p><h3 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h3><p><img src="/2022/01/26/octavia/octavia-component-overview.svg" alt="Octavia组件概述"></p><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p><img src="/2022/01/26/octavia/1628496-20190706173729852-17637913.png" alt="network.png"></p><ul><li><strong>Amphora</strong></li></ul><p>负载均衡的载体，一般为<strong>云主机</strong>。（当然也可以使用物理机，将多个负载均衡配置到同一/两台Amphora节点上，提高数据包转发效率，但是有<strong>单点故障隐患</strong>）</p><ul><li><strong>manage-network</strong></li></ul><p>管理网络，通常管理数据走这条线路，<strong>东侧连接Amphora</strong>，<strong>西侧连接Octavia服务进程</strong>。</p><ul><li><strong>tenant-network</strong></li></ul><p>租户网络，<strong>内部通信使用</strong>，SLB转发报文通过租户网络到各个后端服务器上。</p><ul><li><strong>vip-network</strong></li></ul><p>服务地址，主要用于<strong>对外提供服务</strong>。</p><p>PS：vip-net和tenant-net可以是同一个网络，但是在生产环境中建议分开，以便于更好得划分<strong>网络安全隔离</strong>。</p><ul><li><strong>VM</strong></li></ul><p>后端服务器，用户的真实服务器。</p><ul><li><strong>health-manager</strong></li></ul><p>octavia里面进行健康检查的进程，主要有以下两个作用：</p><ol><li><p><strong>监听来自amphora虚拟机发来的运行状态数据</strong>，以此更新lb，listener，pool，member的状态，同时更新listener_statistics表（可作为计费依据），最重要的是更新<strong>amphora_health</strong>表。</p></li><li><p>根据<strong>amphora_health</strong>数据表中的数据，找到异常状态的amphora虚拟机，对该虚拟机进行<strong>更换操作</strong>。（即删除旧的虚拟机，创建新的虚拟机并下发配置）</p></li></ol><ul><li><strong>house-keeping</strong></li></ul><p>名副其实的 Housekeeping（家政）服务，保障 Octavia 的健康运行。</p><p>主要实现三个功能：</p><ol><li><p>SpareAmphora: <strong>清理虚拟机的池子</strong>, 确保空闲的amphorae池大小。</p></li><li><p>DatabaseCleanup: <strong>定期清理数据库</strong>中已删除的amphorae记录。</p></li><li><p>CertRotation: <strong>定期更新</strong>amphorae中的<strong>证书</strong>。</p></li></ol><ul><li><strong>Octavia Worker</strong></li></ul><p>负责完成 API 请求，是 <strong>Octavia 主干功能的执行者</strong>。</p><p>主要作用是和nova，neutron等组件通信，用于虚拟机调度以及把对于虚拟机操作的指令下发给octavia agent。</p><h3 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h3><p><img src="/2022/01/26/octavia/1628496-20190718210511452-1147299861.png" alt="request.png"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="1-创建负载均衡"><a href="#1-创建负载均衡" class="headerlink" title="1. 创建负载均衡"></a>1. 创建负载均衡</h3><p>通过页面创建负载均衡</p><h3 id="2-查看LB详情"><a href="#2-查看LB详情" class="headerlink" title="2. 查看LB详情"></a>2. 查看LB详情</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openstack loadbalancer show &#123;lbId&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/01/26/octavia/image-20210302181609960.png" alt="image-20210302181609960"></p><p>通过查看详情，知道<code>provider</code>是<code>amphora</code>;</p><p>创建时选择的vpc信息最终生成的ip是一个<strong>VIP</strong>；</p><h3 id="3-查看service项目下的vm信息"><a href="#3-查看service项目下的vm信息" class="headerlink" title="3. 查看service项目下的vm信息"></a>3. 查看service项目下的vm信息</h3><h4 id="负载均衡的虚拟机"><a href="#负载均衡的虚拟机" class="headerlink" title="负载均衡的虚拟机"></a>负载均衡的虚拟机</h4><p>然后查看<code>service</code>项目下的虚拟机信息，发现有多个：</p><p><img src="/2022/01/26/octavia/image-20210302182010345.png" alt="image-20210302182010345"></p><p>这些虚拟机中，最主要的服务就是：<strong>haproxy、octavia-keepalived和amphora-agent服务</strong>；</p><ul><li><p><strong>haproxy、octavia-keepalived</strong>：通过这两个服务实现负载均衡；</p></li><li><p><strong>amphora-agent</strong>：提供Octavia API，并且定时向<strong>health-monitor</strong>发送haproxy的运行时信息，该信息是通过向haproxy进程发送socket查询命令获取到；</p></li></ul><p>存在多个<strong>amphora云主机</strong>是因为开启了集群模式，可以通过查看<code>octavia-api</code>中<code>/etc/octavia/octavia.conf</code>配置文件内容来确认。</p><ol><li><p><code>SINGLE</code>：单机</p></li><li><p><code>ACTIVE_STANDBY</code> ：高可用模式(主备模式)</p></li></ol><p><img src="/2022/01/26/octavia/image-20210302183609566.png" alt="image-20210302183609566"></p><p>同时可以看到，每个<strong>amphora云主机</strong>都使用了两个网络，一个是<strong>lb-mgmt-net</strong>，一个是租户网络(创建负载均衡的时候选择的VPC，也是云主机所在的VPC)，同时Octavia每创建一个 loadbalancer，都会创建包含同样 policy 的 server group(反亲和组)，没有所属租户，用户可见。</p><p><em><strong>即：创建 loadbalancer 的租户只能看到这个 loadbalancer 的信息以及 loadbalancer 所占用的 port（VIP的port）信息，背后的VM、VM的port、SecurityGroup、ServerGroup 都是不可见的。一个 lb 的创建会占用租户 subnet 内的 ip 资源和 port 配额（一般会在 subnet 中创建3个 port）。</strong></em></p><p><img src="/2022/01/26/octavia/image-20210303152421902.png" alt="image-20210303152421902"></p><p>可以看到，这个反亲和组中，默认就添加了amphora的两台机器：</p><p><img src="/2022/01/26/octavia/image-20210303152448987.png" alt="image-20210303152448987"></p><p>在 octavia 中，资源之间的映射关系如下：</p><ul><li>lb：就是两个管理员租户的虚拟机</li><li>listener：虚拟机里面的一个 haproxy 进程，frontend 配置</li><li>pool：haproxy 配置中的一个 backend</li><li>member：backend 配置中的一个 member</li></ul><h4 id="负载均衡的listener"><a href="#负载均衡的listener" class="headerlink" title="负载均衡的listener"></a>负载均衡的listener</h4><p>创建listener其实就是启动haproxy服务，大致分为如下步骤：</p><ol><li>将haproxy的配置文件传到amphora虚拟机中；</li><li>根据虚拟机信息，进行配置修改；</li><li>amphora-agent调用<code>haproxy -c -L &#123;peer&#125; -f &#123;config_file&#125; -f &#123;haproxy_ug&#125;</code>校验配置文件；</li><li>验证无误之后，生成对应该listener的haproxy服务脚本；</li><li>通过amphora-agent启动amphora虚拟机中haproxy服务；<ol><li>先确定listener的配置目录（<code>/var/lib/octavia/&#123;listener-id&#125;/</code>）在不在</li><li>如果是active standby，更新keepalived对各个haproxy的check脚本，<code>/var/lib/octavia/vrrp/check_scripts/haproxy_check_script.sh</code></li><li>启动haproxy服务，<code>service haproxy-&#123;listener_id&#125; start</code></li></ol></li></ol><h4 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h4><p>创建pool的实现基本跟创建listener一致，在amphora中仅仅是在 haproxy 的配置文件增加<code>backend</code>配置；</p><h4 id="添加members"><a href="#添加members" class="headerlink" title="添加members"></a>添加members</h4><p>添加members需要保证网络可达，在OpenStack中，只能选同一子网的云主机，所以网络是连通的；</p><p>octavia已经支持直接指定IP地址添加membe，而不跟虚拟机绑定，前提是用户自己需要保证amphora能够与这个IP地址通信。这种情况最好能在pool上添加 <code>health_monitor</code> 来保证 member 的可用性，这样如果ip地址不可达时，lb也不会将消息路由给它。（OpenStack是在同一子网，可以不开启健康检查）</p><p>因为与member通信的 port 都在namespace中，所以管理 IP 段就可以与租户的网络重叠。</p><h3 id="4-负载均衡实现方式验证"><a href="#4-负载均衡实现方式验证" class="headerlink" title="4. 负载均衡实现方式验证"></a>4. 负载均衡实现方式验证</h3><p>此时，可以通过查看<code>service</code>项目下的虚拟机，来验证<code>Octavia</code>的相关配置是否如预期：</p><p>ssh到<code>service</code>项目下两台虚拟机其中的一台，使用<code>lb-mgmt-net</code>网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh &#123;lb-mgmt-net&#125;</span><br><span class="line">ps -ef |grep keepalived;</span><br><span class="line">cat  /var/lib/octavia/vrrp/octavia-keepalived.conf</span><br></pre></td></tr></table></figure><p>然后会看到具体的配置，总体来说<code>octavia</code>的高可用是通过<strong>haproxy+keepalived</strong>来完成的。</p><h3 id="5-验证负载均衡"><a href="#5-验证负载均衡" class="headerlink" title="5. 验证负载均衡"></a>5. 验证负载均衡</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">openstack loadbalancer show &#123;lbId&#125;  ## 得到vip_network_id</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 然后根据这个id，查询对应的路由信息</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 最终得到路由的id</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 也可以直接通过页面拿到对应的路由的ID</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 执行ip netns 得到对应的网络</span></span></span><br><span class="line">ip netns | grep &#123;routerId&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 执行一下ping，是否可以连通</span></span></span><br><span class="line">ip netns exec qrouter-&#123;routerId&#125; ping &#123;lbVip&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 根据负载均衡选择的监听方式进行验证，此处负载均衡是监听的22端口，进行ssh验证</span></span></span><br><span class="line">ip netns exec qrouter-&#123;routerId&#125; ssh &#123;lbVip&#125;</span><br></pre></td></tr></table></figure><p>负载均衡的监听器，监听的是22端口：</p><p><img src="/2022/01/26/octavia/image-20210303141525891.png" alt="image-20210303141525891"></p><p>查看<code>22pool</code>资源池，映射的也是22端口：</p><p><img src="/2022/01/26/octavia/image-20210303141623791.png" alt="image-20210303141623791"></p><p>然后进行ping的验证：</p><p><img src="/2022/01/26/octavia/image-20210303140307409.png" alt="image-20210303140307409"></p><p>ssh验证：</p><p><img src="/2022/01/26/octavia/image-20210303140336380.png" alt="image-20210303140336380"></p><p>输入密码登录之后，通过<code>ip a</code>查看网卡信息，可以看到此时连到了负载均衡下面资源池中的一台云主机。</p><p>参考： <a href="https://lingxiankong.github.io/2017-09-13-octavia.html">https://lingxiankong.github.io/2017-09-13-octavia.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenStack </tag>
            
            <tag> octavia </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于RBAC的总结-上</title>
      <link href="/2022/01/23/rbac1/"/>
      <url>/2022/01/23/rbac1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是RBAC"><a href="#1-什么是RBAC" class="headerlink" title="1. 什么是RBAC"></a>1. 什么是RBAC</h2><p>RBAC，全称是 Role-Based Access Control ，也就是基于角色的访问控制。<br>RBAC认为权限授权的过程可以抽象地概括为：<code>Who是否可以对What进行How的访问操作，并对这个逻辑表达式进行判断是否为True的求解过程</code>。也即是将权限问题转换为What、How的问题。<br>Who、What、How构成了访问权限三元组。</p><h2 id="2-为什么需要RBAC"><a href="#2-为什么需要RBAC" class="headerlink" title="2. 为什么需要RBAC"></a>2. 为什么需要RBAC</h2><h3 id="2-1-原始权限控制"><a href="#2-1-原始权限控制" class="headerlink" title="2.1 原始权限控制"></a>2.1 原始权限控制</h3><p>在没有RBAC的时候，如果需要对用户授权，则需要直接将权限授予客户，如下图：<br><img src="/2022/01/23/rbac1/img.png" alt="u-p.png"></p><p>张三可以管理商品，同时可以对商品进行审核；<br>李四只能管理商品，无法审核；</p><p>对于这种情况存在以下问题：</p><ol><li>当用户数量很多的时候，需要对每一个用户执行授权操作；</li><li>当权限新增或者删除的时候，也是需要每个用户单独执行；</li><li>当想要快速去除某一部分人的某一部分权限时，操作复杂；</li></ol><h3 id="2-2-RBAC"><a href="#2-2-RBAC" class="headerlink" title="2.2 RBAC"></a>2.2 RBAC</h3><p>针对传统模式的情况，RBAC通过它的权限三元组进行了解决，如图：<br><img src="/2022/01/23/rbac1/img2.png" alt="u-r-p.png"></p><p>在RBAC模型里面，有3个基础组成部分，分别是：用户、角色和权限。<br>通过增加角色，权限与角色进行关联，同时用户与角色进行关联，来解决上面的问题。</p><ol><li>当新增用户时，只需要关联角色，即可获得指定的权限；</li><li>当角色与权限发生变化时，所有关联此角色的用户都会受到影响；</li></ol><h3 id="2-3-RBAC的安全原则"><a href="#2-3-RBAC的安全原则" class="headerlink" title="2.3 RBAC的安全原则"></a>2.3 RBAC的安全原则</h3><ol><li>最小权限原则：RBAC可以将角色配置成其完成任务所需的最小权限集合；</li><li>责任分离原则：可以通过调用相互独立互斥的角色来共同完成敏感的任务；</li><li>数据抽象原则：可以通过权限的抽象来体现，例如资源操作等抽象权限，而不是使用典型的读、写、执行权限；</li></ol><h2 id="3-RBAC模型"><a href="#3-RBAC模型" class="headerlink" title="3. RBAC模型"></a>3. RBAC模型</h2><h3 id="3-1-RBAC0"><a href="#3-1-RBAC0" class="headerlink" title="3.1 RBAC0"></a>3.1 RBAC0</h3><p>RBAC0其实就是上面举的例子，是最简单的实现方式，也是其他RBAC的基础和核心。<br>在RBAC0中，用户角色权限三者关系如下图：<br><img src="/2022/01/23/rbac1/img3.png" alt="rbac.png"><br>一个用户可以关联多个角色，一个角色可以关联多个用户。<br>一个角色可以关联多个权限，一个权限可以关联多个角色。<br>即都为多对多的关联关系。</p><p>一般这种模型对应的数据库表关系如下：<br><img src="/2022/01/23/rbac1/sql.png" alt="table.png"></p><p>常见的就是5张表，用户表、角色表、权限表、用户角色关系表、角色权限关系表；</p><h3 id="3-2-RBAC1"><a href="#3-2-RBAC1" class="headerlink" title="3.2 RBAC1"></a>3.2 RBAC1</h3><p>RBAC1是基于RBAC0模型，引入了角色间的继承关系，即角色上有了上下级的区别。<br>可以给角色分组分层。</p><h3 id="3-3-RBAC2"><a href="#3-3-RBAC2" class="headerlink" title="3.3 RBAC2"></a>3.3 RBAC2</h3><p>RBAC2是基于RBAC0模型的基础上，进行了角色的访问控制。</p><ul><li>比如设置互斥角色，实现责任分离，互斥的角色不能分配给统一用户；</li><li>比如基数约束，即角色可以分配的用户数量受限，或者角色对权限数目受限等；</li></ul><h3 id="3-4-RBAC3"><a href="#3-4-RBAC3" class="headerlink" title="3.4 RBAC3"></a>3.4 RBAC3</h3><p>RBAC3其实就是将RBAC1和RBAC2两个模型进行结合。</p>]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RBAC </tag>
            
            <tag> 权限 </tag>
            
            <tag> 角色 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于RBAC的总结-下</title>
      <link href="/2022/01/23/rbac2/"/>
      <url>/2022/01/23/rbac2/</url>
      
        <content type="html"><![CDATA[<h2 id="关于实现方案的简单记录"><a href="#关于实现方案的简单记录" class="headerlink" title="关于实现方案的简单记录"></a>关于实现方案的简单记录</h2><p> 通过<a href="../rbac1">关于RBAC实现的方案记录-上</a>，我们了解到了RBAC的一些基础知识，下面是实际使用中的一些案例情况。</p><h2 id="1-简单模式"><a href="#1-简单模式" class="headerlink" title="1. 简单模式"></a>1. 简单模式</h2><p>在常见的平台中，一般会内置超级管理员角色以及admin/root的账号，默认拥有一些或者全部的权限。<br>同时还会内置限制，只有超级管理员才能创建角色、给角色授权，其他的角色是无权操作这些的。<br>对于这种情况，使用的就是RBAC0的模型，有以下特点：</p><ol><li>只有超级管理员可以创建角色、授权角色；</li><li>所有角色都是平级，修改授权时，不会对其他角色造成影响；</li></ol><h2 id="2-级联模式"><a href="#2-级联模式" class="headerlink" title="2. 级联模式"></a>2. 级联模式</h2><p>对于级联模式，使用的就是RBAC1的模型，对角色进行分层，使得角色之间有继承关系。<br>它的特点如下：</p><ol><li>创建角色时，需要选父级角色；</li><li>对上级角色的授权进行修改时，主要是删减，会影响到子角色，需要自动对齐；</li></ol><p>此时根据业务需求，就可以满足：</p><ol><li>允许超级管理员操作角色和权限；</li><li>也允许将角色操作下放至其他角色，进行数据权限限制；</li><li>超级管理员修改角色A的权限时，权限自动收敛，所以A的子角色自动变化；</li></ol><p>如果同时将角色和权限的操作下放至其他角色，可能会出现的情况如下：</p><ol><li>角色A添加了一个权限，是否允许超级管理员将其分配给其他角色；</li><li>角色A修改了一个权限的配置，会影响到其他平级等角色，不安全；</li></ol><p>所以，一般情况下不会使用这种完全下放的权限管理，实际应用中还是超级管理员一个人操作这些模块的居多。</p><h2 id="3-数据隔离"><a href="#3-数据隔离" class="headerlink" title="3.数据隔离"></a>3.数据隔离</h2><p>在工作中，我遇到的需求如下：</p><blockquote><p>平台需要给集团A准备好角色，集团A给子公司的管理员授权之后，子公司X自己可以创建角色、权限等，子公司之间是互相隔离。</p></blockquote><p>对于这种必须授权的情况，一般可以通过数据权限隔离，达到效果，即：</p><ol><li>权限授予之后，角色A只能看到它数据权限范围内的数据，它的操作不影响其他角色；</li><li>超级管理员只管理功能权限，其他权限它不关注；</li></ol><p>一般的数据隔离都是通过组织架构来区分，也就是给数据标记上属于什么组织，然后通过组织树型关系，每个组织只能看到自己以及自己的子组织的数据。<br>同时角色创建时，也需要赋予组织属性，就可以实现登录后根据登录者的角色所属组织，进行查询时的数据权限过滤。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>本次记录属于日记形式，如有变化，后续再更新~</p>]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RBAC </tag>
            
            <tag> 权限 </tag>
            
            <tag> 角色 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习笔记-手写简单的Mybatis</title>
      <link href="/2020/01/23/mybatis4/"/>
      <url>/2020/01/23/mybatis4/</url>
      
        <content type="html"><![CDATA[<h2 id="1-传统的JDBC模式"><a href="#1-传统的JDBC模式" class="headerlink" title="1. 传统的JDBC模式"></a>1. 传统的JDBC模式</h2><p>在没有使用ORM框架时，我们基本都是通过JDBC进行数据库的操作，一般的逻辑代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Connection connection = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement preparedStatement = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加载数据库驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过驱动管理类获取数据库链接</span></span><br><span class="line">        connection = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?</span></span><br><span class="line"><span class="string">characterEncoding=utf-8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="comment">// 定义sql语句？表示占位符</span></span><br><span class="line">        String sql = <span class="string">&quot;select * from user where username = ?&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取预处理statement</span></span><br><span class="line">        preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">        <span class="comment">// 设置参数，第一个参数为sql语句中参数的序号(从1开始)，第二个参数为设置的参数值</span></span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        <span class="comment">// 向数据库发出sql执行查询，查询出结果集</span></span><br><span class="line">        resultSet = preparedStatement.executeQuery();</span><br><span class="line">        <span class="comment">// 遍历查询结果集</span></span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = resultSet.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            String username = resultSet.getString(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">            <span class="comment">// 封装User</span></span><br><span class="line">            user.setId(id);</span><br><span class="line">            user.setUsername(username);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (preparedStatement != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                preparedStatement.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对JDBC的代码进行分析，可以发现存在以下问题：</p><ol><li>数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能；</li><li>Sql语句在代码中硬编码，造成代码不易维护，实际应用中sql变化的可能较大，sql变动需要改变java代码；</li><li>使用<code>preparedStatement</code>向占位符传参存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护；</li><li>对结果集解析存在硬编码(查询列名)，sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便；</li></ol><p>由于硬编码可以通过配置文件解决，针对上述的问题，所以我们可以想到如下的解决思路：</p><ol><li>使用数据库连接池初始化连接资源；</li><li>将sql语句抽取到xml配置文件中；</li><li>使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射；</li></ol><p>根据上述的思路进行自定义的Mybatis框架编写。</p><h2 id="2-客户端开发"><a href="#2-客户端开发" class="headerlink" title="2. 客户端开发"></a>2. 客户端开发</h2><p>首先客户端要提供数据库的连接信息以及SQL的信息。<br>根据设计思路，这些信息通过配置文件来解决，所以在<code>resources</code>目录下创建<code>sqlMapConfig.xml</code>文件，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库配置信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个文件中配置了要加载那些mapper.xml，这样只需要加载一次就完成了所有的加载。<br>在同个目录下创建映射配置文件<code>UserMapper.xml</code>，并定义了简单的增删改查的SQL。内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.ormtest.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.ormtest.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOne&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.ormtest.pojo.User&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.ormtest.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;id&#125; and username = #&#123;username&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--添加用户--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.ormtest.pojo.User&quot;</span> &gt;</span></span><br><span class="line">        insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--修改--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.ormtest.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        update user set username = #&#123;username&#125; where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--删除--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">        delete from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时也要生成对应的POJO对象，并定义Dao层接口，代码简单，此处就不粘贴了。<br>到此为止，客户的代码就编写完成了，等完成框架的编写之后，就可以进行测试了。</p><h2 id="3-自定义框架开发"><a href="#3-自定义框架开发" class="headerlink" title="3. 自定义框架开发"></a>3. 自定义框架开发</h2><p>开发的时候，我们根据逻辑流程一步步进行。</p><p>首先我们需要一个类来接受和加载核心配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将xml配置文件加载成为字节流</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InputStream <span class="title">getResourceAsSteam</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        InputStream resourceAsStream = Resources.class.getClassLoader().getResourceAsStream(path);</span><br><span class="line">        <span class="keyword">return</span> resourceAsStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心配置文件加载完成之后，就需要对字节流进行解析，所以声明一个解析xml的类，最终这个类要返回一个SqlSessionFactory的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionFactoryBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用构造器模式，将复杂对象进行逐步构建</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 使用dom4j读取字节流（也就是核心配置文件）的内容</span></span><br><span class="line">        <span class="comment">// 封装成一个configuration对象</span></span><br><span class="line">        XMLConfigBuilder xmlConfigBuilder = <span class="keyword">new</span> XMLConfigBuilder();</span><br><span class="line">        Configuration configuration = xmlConfigBuilder.parseConfig(in);</span><br><span class="line">        <span class="comment">// 根据配置信息创建sqlSession的工厂</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> DefaultSqlSessionFactory(configuration);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个解析的过程中，声明了一些解析类，比如<code>XMLConfigBuilder</code>进行核心配置文件的解析，里面还嵌套调用了<code>mapper.xml</code>的解析类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLConfigBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DRIVER = <span class="string">&quot;driver&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JDBCURL = <span class="string">&quot;jdbcUrl&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME = <span class="string">&quot;username&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">&quot;password&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XMLConfigBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过dom4j进行字节流解析</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Configuration <span class="title">parseConfig</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> DocumentException, PropertyVetoException </span>&#123;</span><br><span class="line">        <span class="comment">// 借助dom4j，进行解析，得到整个的文档对象</span></span><br><span class="line">        Document document = <span class="keyword">new</span> SAXReader().read(inputStream);</span><br><span class="line">        <span class="comment">// 得到根对象，即configuration标签</span></span><br><span class="line">        Element rootElement = document.getRootElement();</span><br><span class="line">        <span class="comment">// 获取property标签，进行数据库连接信息的解析加载</span></span><br><span class="line">        List&lt;Element&gt; elementList = rootElement.selectNodes(<span class="string">&quot;//property&quot;</span>);</span><br><span class="line">        <span class="comment">// 借助properties对象，进行属性保存</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">for</span> (Element element : elementList) &#123;</span><br><span class="line">            String name = element.attributeValue(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            String value = element.attributeValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">            properties.setProperty(name, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行数据库连接信息封装，使用C3P0连接池</span></span><br><span class="line">        ComboPooledDataSource comboPooledDataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">        comboPooledDataSource.setDriverClass(properties.getProperty(DRIVER));</span><br><span class="line">        comboPooledDataSource.setJdbcUrl(properties.getProperty(JDBCURL));</span><br><span class="line">        comboPooledDataSource.setUser(properties.getProperty(USERNAME));</span><br><span class="line">        comboPooledDataSource.setPassword(properties.getProperty(PASSWORD));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据源进行保存</span></span><br><span class="line">        configuration.setDataSource(comboPooledDataSource);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行mapper.xml的解析工作</span></span><br><span class="line">        <span class="comment">// 首先得到需要加载的xml</span></span><br><span class="line">        List&lt;Element&gt; mappers = rootElement.selectNodes(<span class="string">&quot;//mapper&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Element element : mappers) &#123;</span><br><span class="line">            <span class="comment">// 得到需要加载的mapper文件路径</span></span><br><span class="line">            String mapperPath = element.attributeValue(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">            <span class="comment">// 对mapper文件进行解析，得到mapperstatement</span></span><br><span class="line">            InputStream resourceAsSteam = Resources.getResourceAsSteam(mapperPath);</span><br><span class="line">            XMLMapperBuilder xmlMapperBuilder = <span class="keyword">new</span> XMLMapperBuilder(configuration);</span><br><span class="line">            xmlMapperBuilder.parseMapper(resourceAsSteam);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回整体配置对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.configuration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过解析<code>mapper.xml</code>，生成对应的<code>mappedStatement</code>对象，存入<code>Configuration</code>对象中，因为全局只有一个<code>Configuration</code>对象，所以每次都把这个对象进行传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLMapperBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XMLMapperBuilder</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用dom4j解析mapper.xml</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseMapper</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> DocumentException </span>&#123;</span><br><span class="line">        Document document = <span class="keyword">new</span> SAXReader().read(inputStream);</span><br><span class="line">        Element rootElement = document.getRootElement();</span><br><span class="line">        <span class="comment">// 得到当前mapper的namespace</span></span><br><span class="line">        String namespace = rootElement.attributeValue(<span class="string">&quot;namespace&quot;</span>);  </span><br><span class="line">        <span class="comment">//递归遍历当前节点所有的子节点</span></span><br><span class="line">        List&lt;Element&gt; elementList = rootElement.elements();</span><br><span class="line">        <span class="keyword">for</span> (Element element : elementList) &#123;</span><br><span class="line">            String id = element.attributeValue(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            String resultType = element.attributeValue(<span class="string">&quot;resultType&quot;</span>);</span><br><span class="line">            String parameterType = element.attributeValue(<span class="string">&quot;parameterType&quot;</span>);</span><br><span class="line">            String sqlText = element.getTextTrim();</span><br><span class="line">            MappedStatement mappedStatement = <span class="keyword">new</span> MappedStatement();</span><br><span class="line">            mappedStatement.setId(id);</span><br><span class="line">            mappedStatement.setResultType(resultType);</span><br><span class="line">            mappedStatement.setParameterType(parameterType);</span><br><span class="line">            mappedStatement.setSql(sqlText);</span><br><span class="line">            <span class="comment">// 增加sql类型字段</span></span><br><span class="line">            mappedStatement.setSqlCommandType(element.getName());</span><br><span class="line">            <span class="comment">// mapper的namespace和SQL语句的id，组成唯一id</span></span><br><span class="line">            String key = namespace+<span class="string">&quot;.&quot;</span>+id;</span><br><span class="line">            configuration.getMappedStatementMap().put(key,mappedStatement);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，所有的配置文件都加载完成，最终根据生成的<code>Configuration</code>对象，返回对应的<code>SqlSessionFactory</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSessionFactory</span> <span class="keyword">implements</span> <span class="title">SqlSessionFactory</span></span>&#123;</span><br><span class="line">    <span class="comment">// 通过构造方法注入，保证从上到下只有一个configuration对象</span></span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSessionFactory</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当客户端调用<code>openSession</code>方法时，就会返回一个<code>SqlSession</code>对象，该对象里面封装了增删改查的方法，供客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSession</span> <span class="keyword">implements</span> <span class="title">SqlSession</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSession</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doQuery</span><span class="params">(String statementId, <span class="keyword">boolean</span> resultTypeFlag, Object... params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 根据statementId得到要执行的SQL对象</span></span><br><span class="line">        MappedStatement mappedStatement = configuration.getMappedStatementMap().get(statementId);</span><br><span class="line">        <span class="comment">// 判断当前的SQL类型是什么</span></span><br><span class="line">        <span class="keyword">switch</span> (mappedStatement.getSqlCommandType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;select&quot;</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (resultTypeFlag) &#123;</span><br><span class="line">                    <span class="keyword">return</span> selectList(statementId, params);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> selectOne(statementId, params);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;insert&quot;</span>:&#123;</span><br><span class="line">                <span class="keyword">return</span> insert(statementId, params);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;update&quot;</span>:&#123;</span><br><span class="line">                <span class="keyword">return</span> update(statementId, params);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;delete&quot;</span>:&#123;</span><br><span class="line">                <span class="keyword">return</span> delete(statementId, params);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statementId, Object... params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 根据statementId得到要执行的SQL对象</span></span><br><span class="line">        MappedStatement mappedStatement = configuration.getMappedStatementMap().get(statementId);</span><br><span class="line">        Executor executor = <span class="keyword">new</span> SimpleExecutor();</span><br><span class="line">        List&lt;Object&gt; result = executor.query(configuration, mappedStatement, params);</span><br><span class="line">        <span class="keyword">return</span> (List&lt;E&gt;) result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statementId, Object... params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Object&gt; objects = <span class="keyword">this</span>.selectList(statementId, params);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == objects.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) objects.get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;查询结果为空或查询结果过多&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(String statementId, Object... params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MappedStatement mappedStatement = configuration.getMappedStatementMap().get(statementId);</span><br><span class="line">        Executor executor = <span class="keyword">new</span> SimpleExecutor();</span><br><span class="line">        executor.updateDatabase(configuration, mappedStatement, params);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String statementId, Object... params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MappedStatement mappedStatement = configuration.getMappedStatementMap().get(statementId);</span><br><span class="line">        Executor executor = <span class="keyword">new</span> SimpleExecutor();</span><br><span class="line">        executor.updateDatabase(configuration, mappedStatement, params);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(String statementId, Object... params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MappedStatement mappedStatement = configuration.getMappedStatementMap().get(statementId);</span><br><span class="line">        Executor executor = <span class="keyword">new</span> SimpleExecutor();</span><br><span class="line">        executor.updateDatabase(configuration, mappedStatement, params);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据JDK动态代理生成代理对象，对方法进行加工</span></span><br><span class="line">        Object proxyInstance = Proxy.newProxyInstance(DefaultSqlSession.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;mapperClass&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// 这里无法获取mapper.xml的信息，所以为了方便识别，需要将namespace和SQL语句的id与接口的全限定名和方法保持一致</span></span><br><span class="line">                <span class="comment">// 获取方法名</span></span><br><span class="line">                String methodName = method.getName();</span><br><span class="line">                <span class="comment">// 获取所属的接口class名称</span></span><br><span class="line">                String className = method.getDeclaringClass().getName();</span><br><span class="line">                <span class="comment">// 得到唯一的statementId</span></span><br><span class="line">                String statementId = className + <span class="string">&quot;.&quot;</span> + methodName;</span><br><span class="line">                <span class="comment">// 根据方法的返回结果类型进行判断</span></span><br><span class="line">                Type genericReturnType = method.getGenericReturnType();</span><br><span class="line">                <span class="keyword">if</span>(genericReturnType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                    <span class="keyword">return</span> doQuery(statementId, <span class="keyword">true</span>, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> doQuery(statementId, <span class="keyword">false</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (T) proxyInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的增删改查操作实际上还是通过JDBC来实现，所以声明一个<code>Executor</code>类来专门执行具体操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Configuration configuration, MappedStatement mappedStatement, Object... params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PreparedStatement preparedStatement = getPreparedStatement(configuration, mappedStatement, params);</span><br><span class="line">        <span class="comment">// 6 执行SQL，得到结果集</span></span><br><span class="line">        ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">        <span class="comment">// 7 对结果集进行转换</span></span><br><span class="line">        List&lt;Object&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 7.1 得到返回结果的类型</span></span><br><span class="line">        String resultType = mappedStatement.getResultType();</span><br><span class="line">        <span class="comment">// 7.2 转换为类</span></span><br><span class="line">        Class&lt;?&gt; resultTypeClass = getClassType(resultType);</span><br><span class="line">        <span class="comment">// 7.3 遍历结果集，逐个进行转换</span></span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            <span class="comment">// 声明返回类</span></span><br><span class="line">            Object o = resultTypeClass.newInstance();</span><br><span class="line">            <span class="comment">// 获取元数据</span></span><br><span class="line">            ResultSetMetaData metaData = resultSet.getMetaData();</span><br><span class="line">            <span class="comment">// 此处是从1开始</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= metaData.getColumnCount(); i++) &#123;</span><br><span class="line">                <span class="comment">// 字段名</span></span><br><span class="line">                String columnName = metaData.getColumnName(i);</span><br><span class="line">                <span class="comment">// 对应字段的值</span></span><br><span class="line">                Object value = resultSet.getObject(columnName);</span><br><span class="line">                <span class="comment">//使用内省，根据数据库表字段和实体属性的对应关系，完成封装</span></span><br><span class="line">                PropertyDescriptor propertyDescriptor = <span class="keyword">new</span> PropertyDescriptor(columnName, resultTypeClass);</span><br><span class="line">                <span class="comment">// 获取写方法，进行值写入</span></span><br><span class="line">                Method writeMethod = propertyDescriptor.getWriteMethod();</span><br><span class="line">                writeMethod.invoke(o,value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将本次转换的结果加入返回结果中</span></span><br><span class="line">            resultList.add(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (List&lt;E&gt;) resultList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateDatabase</span><span class="params">(Configuration configuration, MappedStatement mappedStatement, Object... params)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException, IllegalAccessException, NoSuchFieldException </span>&#123;</span><br><span class="line">        PreparedStatement preparedStatement = getPreparedStatement(configuration, mappedStatement, params[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">boolean</span> execute = preparedStatement.execute();</span><br><span class="line">        <span class="keyword">return</span> execute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> PreparedStatement <span class="title">getPreparedStatement</span><span class="params">(Configuration configuration, MappedStatement mappedStatement, Object... params)</span> <span class="keyword">throws</span> SQLException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">// 执行jdbc过程</span></span><br><span class="line">        <span class="comment">// 1 注册驱动获取连接，直接获取C3P0连接池里的连接</span></span><br><span class="line">        Connection connection = configuration.getDataSource().getConnection();</span><br><span class="line">        <span class="comment">// 2 获取要执行的SQL</span></span><br><span class="line">        String sql = mappedStatement.getSql();</span><br><span class="line">        <span class="comment">// 3 对SQL中存在的参数进行提取和转换</span></span><br><span class="line">        BoundSql boundSql = getBoundSql(sql);</span><br><span class="line">        <span class="comment">// 4 获取预处理对象</span></span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(boundSql.getSqlText());</span><br><span class="line">        <span class="comment">// 5 设置参数</span></span><br><span class="line">        <span class="comment">// 5.1 获取参数类型</span></span><br><span class="line">        String parameterType = mappedStatement.getParameterType();</span><br><span class="line">        <span class="comment">// 5.2 根据类型获取类</span></span><br><span class="line">        Class&lt;?&gt; parameterTypeClass = getClassType(parameterType);</span><br><span class="line">        <span class="comment">// 5.3 得到解析的参数列表</span></span><br><span class="line">        List&lt;ParameterMapping&gt; parameterMappingList = boundSql.getParameterMappingList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappingList.size(); i++) &#123;</span><br><span class="line">            ParameterMapping parameterMapping = parameterMappingList.get(i);</span><br><span class="line">            <span class="comment">// 得到参数值，即#&#123;id&#125;中的id</span></span><br><span class="line">            String content = parameterMapping.getContent();</span><br><span class="line">            Field declaredField = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 判断是否是基本数据类型或者其包装类</span></span><br><span class="line">            <span class="keyword">if</span> (isCommonDataType(parameterTypeClass) || isWrapClass(parameterTypeClass)) &#123;</span><br><span class="line">                declaredField = parameterTypeClass.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                declaredField = parameterTypeClass.getDeclaredField(content);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置权限暴力访问，防止属性私有不让访问</span></span><br><span class="line">            declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 得到对应的值</span></span><br><span class="line">            Object o = declaredField.get(params[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 将参数拼接到SQL上</span></span><br><span class="line">            preparedStatement.setObject(i + <span class="number">1</span>, o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preparedStatement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当前类型是否是基本数据类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Boolean <span class="title">isCommonDataType</span><span class="params">(Class clazz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clazz.isPrimitive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isWrapClass</span><span class="params">(Class clazz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Class) clazz.getField(<span class="string">&quot;TYPE&quot;</span>).get(<span class="keyword">null</span>)).isPrimitive();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据类型获取对应的class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; getClassType(String type) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span>(type != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(type);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对mapper中的原SQL进行解析和替换</span></span><br><span class="line"><span class="comment">     * 由于jdbc只认识?占位符，所以要把#&#123;id&#125;进行替换</span></span><br><span class="line"><span class="comment">     * 同时要得到其中的id，用于定位获取参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> BoundSql <span class="title">getBoundSql</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 标记处理类</span></span><br><span class="line">        ParameterMappingTokenHandler parameterMappingTokenHandler = <span class="keyword">new</span> ParameterMappingTokenHandler();</span><br><span class="line">        <span class="comment">// 第一个参数是开始标记、第二个是结束标记、第三个是使用那个处理类</span></span><br><span class="line">        GenericTokenParser genericTokenParser = <span class="keyword">new</span> GenericTokenParser(<span class="string">&quot;#&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, parameterMappingTokenHandler);</span><br><span class="line">        <span class="comment">// 得到处理后的SQL（参数已经变为?）</span></span><br><span class="line">        String formatSql = genericTokenParser.parse(sql);</span><br><span class="line">        <span class="comment">// 处理过程中，处理类已经将参数中的值进行了存储，直接获取即可</span></span><br><span class="line">        List&lt;ParameterMapping&gt; parameterMappings = parameterMappingTokenHandler.getParameterMappings();</span><br><span class="line">        <span class="comment">// 通过构造方法进行赋值</span></span><br><span class="line">        BoundSql boundSql = <span class="keyword">new</span> BoundSql(formatSql, parameterMappings);</span><br><span class="line">        <span class="keyword">return</span> boundSql;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一些基础的POJO这里就不再粘贴了，到此，框架的代码就基本开发完毕，下面进行测试。</p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h2><p>在客户端里声明测试类，进行如下的代码编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在测试方法执行前执行</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 将配置文件进行加载，得到字节流</span></span><br><span class="line">        InputStream resourceAsSteam = Resources.getResourceAsSteam(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 此次加载会将xml文件里面的内容加载到框架内</span></span><br><span class="line">        <span class="comment">// 通过字节流，得到sqlSession工厂</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(resourceAsSteam);</span><br><span class="line">        <span class="comment">// 通过工厂的openSession方法，生成一个session</span></span><br><span class="line">        sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不使用代理的模式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = sqlSession.selectList(<span class="string">&quot;com.ormtest.mapper.UserMapper.selectAll&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用代理模式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectAll();</span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终测试通过，查询结果正确。</p><p>至此，自定义Mybatis的简单实现就完成了~~</p>]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记-动态代理</title>
      <link href="/2020/01/23/java-dynamic-proxy/"/>
      <url>/2020/01/23/java-dynamic-proxy/</url>
      
        <content type="html"><![CDATA[<h2 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. 代理模式</h2><pre><code>代理模式一般指的是一个类代表另一个类的功能。这种类型的设计模式属于结构型模式，通过创建具有现有对象的对象，以便向外界提供功能接口。</code></pre><p>这里来举例说明：<br>歌星A，擅长唱歌；某晚会邀请A去唱歌，但是实际上不会直接联系A，而是联系A的经纪人B，经纪人经过合同谈判等步骤，最终A去晚会上进行了唱歌。<br>首先定义个接口Star里面定义了唱歌方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Star</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 唱歌</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 跳舞</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">dance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后声明实现类歌星A：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RapStar</span> <span class="keyword">implements</span> <span class="title">Star</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;RapStar开始freestyle！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;RapStar开始地板动作！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们会定义一个经纪人类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Broker</span> <span class="keyword">implements</span> <span class="title">Star</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> RapStar rapStar;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Broker</span><span class="params">(RapStar rapStar)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.rapStar = rapStar;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;价钱谈好了，经纪人抽取提成......&quot;</span>);</span><br><span class="line">      rapStar.sing();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;价钱谈崩了，经纪人表示不跳舞&quot;</span>);</span><br><span class="line">      <span class="comment">// rapStar.dance();</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实际的调用就会是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Party</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     RapStar rapStar = <span class="keyword">new</span> RapStar();</span><br><span class="line">     System.out.println(<span class="string">&quot;今晚邀请了明星A&quot;</span>);</span><br><span class="line">      Star star = <span class="keyword">new</span> Broker(rapStar);</span><br><span class="line">      star.sing();</span><br><span class="line">      star.dance();  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出就会是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">今晚邀请了明星A</span><br><span class="line">价钱谈好了，经纪人抽取提成......</span><br><span class="line">RapStar开始freestyle！</span><br><span class="line">价钱谈崩了，经纪人表示不跳舞</span><br></pre></td></tr></table></figure><p>这样就达到了，在RapStar不变的情况下，进行方法的增强。</p><h2 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h2><p>静态代理就是在编译时就指定的代理，比如上述的例子中，指定了Broker代理RapStar，但是当现在来了一个演员明星ActorStar的时候，也需要Broker去代理，这时就不支持了，需要进行代码的修改。</p><h2 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h2><p>为了解决静态代理的问题，让程序动态的根据要进行代理的类自动生成代理类，这个就是动态代理。<br>常用的动态代理有两种：JDK动态代理、cglib动态代理。</p><h4 id="3-1-JDK动态代理"><a href="#3-1-JDK动态代理" class="headerlink" title="3.1 JDK动态代理"></a>3.1 JDK动态代理</h4><p>JDK动态代理的实现方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> method.invoke(obj, args);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过查看参数以及查看源码，可以知道：<br>使用JDK动态代理的类，必须实现某个接口（第二个参数需要传入实现的接口），最终底层会生成一个和当前需要代理的类实现了相同接口的类，实现了代理功能（类似上面的例子）。</p><h4 id="3-2-cglib动态代理"><a href="#3-2-cglib动态代理" class="headerlink" title="3.2 cglib动态代理"></a>3.2 cglib动态代理</h4><p>cglib动态代理的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Enhancer.create(obj.getClass(), <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(obj, objects);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>通过查看参数以及查看源码，可以知道：<br>使用cglib动态代理的类，不需要实现接口（可实现可不实现，不关注），它只有两个参数，最终底层是根据当前需要代理类，派生出一个子类，通过子类的方式实现了方法的代理增强。</p><p>两个动态代理都是通过里面的<code>invoke/intercept</code>方法，进行方法的代理增强。</p>]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习笔记-源码解读与插件原理</title>
      <link href="/2020/01/23/mybatis3/"/>
      <url>/2020/01/23/mybatis3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-mybatis架构简介"><a href="#1-mybatis架构简介" class="headerlink" title="1. mybatis架构简介"></a>1. mybatis架构简介</h2><blockquote><p>Mybatis的架构可以大致分为以下三层：<br>1、API接口层：对外提供增删改查接口，使用传统的MyBatis提供的API或者使用Mapper代理的方式；<br>2、数据处理层：完成参数映射、SQL解析与执行、结果处理等；<br>3、框架支撑层：支持基于XML或者注解定义SQL、事务管理、连接池管理、缓存管理等；</p></blockquote><p><strong>Mybatis作为一个ORM框架，实际上底层还是通过JDBC来操作数据库，完成增删改查的。</strong></p><p>想要详细了解底层的原理，首先需要知道Mybatis的九大核心的概念：<br>|组件  |作用  |<br>|–|–|<br>| SqlSession|作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成数据库增删改查功能|<br>|Executor|MyBatis执行器，是MyBatis调度的核心，负责SQL语句的生成和查询缓存的维护|<br>|StatementHandler|封装了JDBC Statement操作，负责对JDBC statement的操作，如设置参数、将Statement结果集转换成List集合|<br>|ParameterHandler|负责对用户传递的参数转换成JDBC Statement所需要的参数|<br>|ResultSetHandler|负责将JDBC返回的ResultSet结果集对象转换成List类型的集合|<br>|TypeHandler|负责java数据类型和jdbc数据类型之间的映射和转换|<br>|MappedStatement|MappedStatement维护了一条<code>＜select | update | delete | insert＞</code>节点的封装|<br>|SqlSource|负责根据用户传递的<code>parameterObject</code>，动态地生成SQL语句，将信息封装到<code>BoundSql</code>对象中，并返回|<br>|BoundSql |表示动态生成的SQL语句以及相应的参数信息|</p><p>Mybatis完成一次查询或者其他操作的大致流程如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201023154330286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xmajM5NzQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>简单描述Mybatis执行过程如下：</p><ol><li>加载核心配置文件，得到数据库连接信息，创建核心配置对象保存生成的连接池等信息；</li><li>加载映射配置文件，将<code>namespace</code>和SQL语句标签的<code>id</code>，组合作为id，最终封装成为一个<code>MappedStatement</code>对象，存放到内存中；</li><li>调用<code>OpenSession</code>方法获得会话，然后调用相应的增删改查方法，方法参数为<code>namespace+id</code>；</li><li>接收到处理请求，由<code>Executor</code>的默认实现类<code>BaseExecutor</code>来处理，首先封装<code>BoundSql</code>对象，并根据分页等信息生成缓存的Key；</li><li>判断缓存中是否有，如果有则返回，如果没有进行数据库的查询；</li><li>进入<code>SimpleExecutor</code>中进行数据库的查询，调用<code>StatementHandler</code>来处理，而它先通过<code>ParameterHandler</code>进行参数设置，通过<code>TypeHandler</code>将java类型转换成为数据库类型；</li><li>最终调用JDBC的操作，完成查询，得到<code>ResultSet</code>；</li><li>然后通过<code>ResultSetHandler</code>处理器将结果进行处理，最终返回指定的结果类型；</li></ol><h2 id="2-mybatis源码分析"><a href="#2-mybatis源码分析" class="headerlink" title="2. mybatis源码分析"></a>2. mybatis源码分析</h2><p>首先，通过传统模式调用mybatis的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">//1.加载核心配置文件为字节流</span></span><br><span class="line">       InputStream resourceAsStream = Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">       <span class="comment">//2.解析配置文件，并创建了sqlSessionFactory</span></span><br><span class="line">       SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(resourceAsStream);</span><br><span class="line">       <span class="comment">//3.开启一个sqlSession会话，此处可以传参boolean类型，参数表示事务是否自动提交，目前是需要手动提交</span></span><br><span class="line">       SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">       <span class="comment">//4.sqlSession调用方法，传入namespace+id</span></span><br><span class="line">       List&lt;User&gt; users = sqlSession.selectList(<span class="string">&quot;user.findAll&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">           System.out.println(user);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 最终关闭会话</span></span><br><span class="line">       sqlSession.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这种传统方式的缺点也很明显，<code>namespace+id是硬编码</code>，如果很多地方使用时，发生变化，则需要修改所有的地方。<br>针对这个问题，Mybatis还支持动态代理的方式，就是通过<code>getMapper</code>的方式，无需指定:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       InputStream resourceAsStream = Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">       SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(resourceAsStream);</span><br><span class="line">       SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">       UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">       List&lt;User&gt; userList= mapper.findAllUser();</span><br><span class="line">       <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">           System.out.println(user);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这种代理方式是如何实现的呢？<br>下面跟随源码进行查看，通过一步一步的进入，发现从<code>SqlSession</code>的实现类<code>DefaultSqlSession</code>一直到<code>MapperProxyFactory</code>最终找到具体的实现方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[]&#123;mapperInterface&#125;, mapperProxy);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//MapperProxyFactory类中的newInstance方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 创建了JDK动态代理的invocationHandler接口的实现类mapperProxy</span></span><br><span class="line">       <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">       <span class="comment">// 调用了重载方法</span></span><br><span class="line">       <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>到此处我们可以确定Mybatis是通过<code>JDK动态代理</code>的方式进行代理对象的产生。</p><p><strong>同时，这里也可以解释为什么Mybatis规定Mapper的namespace要和mapper的全限定名一致，为什么SQL语句的id要与方法名一致。<br>因为，动态代理中只能获取到要执行哪个类下的哪个方法，无法获取xml里面的信息，所以让两者保持一致，可以直接定位到具体要执行的是哪个SQL。</strong></p><p>通过JDK动态代理的参数可知，最终是由<code>MapperProxy</code>来进行的代理增强，进入其中查看<code>invoke</code>发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">               <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">               <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">       <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>所以最终通过<code>method</code>参数获取到要执行的是哪个SQL，最终交给<code>mapperMethod</code>完成执行，进行上面讲的步骤，最终得到结果。</p><h2 id="3-插件原理与自定义"><a href="#3-插件原理与自定义" class="headerlink" title="3. 插件原理与自定义"></a>3. 插件原理与自定义</h2><p>插件对mybatis来说就是拦截器，用来增强核心对象的功能，增强功能本质上是借助于底层的动态代理实现的。</p><p>Mybatis对持久层的操作就是借助于四大核心对象，<code>Executor、StatementHandler、ParameterHandler、ResultSetHandler</code>，在上面分析源码时，会发现这四大核心对象都有拦截判断，我们就是通过拦截这四大对象来进行插件的开发。</p><p>进入<code>org.apache.ibatis.session.Configuration</code>核心配置类中，可以看到针对<code>Executor</code>的拦截器判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获得执行器类型</span></span><br><span class="line">       executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType; <span class="comment">// 使用默认</span></span><br><span class="line">       executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType; <span class="comment">// 使用 ExecutorType.SIMPLE</span></span><br><span class="line">       <span class="comment">// 创建对应实现的 Executor 对象</span></span><br><span class="line">       Executor executor;</span><br><span class="line">       <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">           executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">           executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果开启缓存，创建 CachingExecutor 对象，进行包装</span></span><br><span class="line">       <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">           executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 此处是加载所有的针对Executor的插件</span></span><br><span class="line">       executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">       <span class="keyword">return</span> executor;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>针对<code>ParameterHandler</code>的插件加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 创建 ParameterHandler 对象</span></span><br><span class="line">       ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">       <span class="comment">// 此处是加载所有的针对ParameterHandler的插件</span></span><br><span class="line">       parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">       <span class="keyword">return</span> parameterHandler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>针对<code>StatementHandler </code>插件加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 创建 RoutingStatementHandler 对象</span></span><br><span class="line">       StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">       <span class="comment">// 此处是加载所有的针对StatementHandler的插件</span></span><br><span class="line">       statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">       <span class="keyword">return</span> statementHandler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>针对<code>ResultSetHandler</code>插件加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 创建 DefaultResultSetHandler 对象</span></span><br><span class="line">       ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">       <span class="comment">// 此处是加载所有的针对ResultSetHandler的插件</span></span><br><span class="line">       resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">       <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过上面的源码我们会发现，在这四大对象创建的时候会进行插件的加载，而且加载的方法是相同的，都是<code>interceptorChain.pluginAll()</code>，所以我们进入该方法，查看具体的加载逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">           target = interceptor.plugin(target);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> target;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在深入进入会发现如下逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获得拦截的方法映射</span></span><br><span class="line">       Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">       <span class="comment">// 获得目标类的类型</span></span><br><span class="line">       Class&lt;?&gt; type = target.getClass();</span><br><span class="line">       <span class="comment">// 获得目标类的接口集合</span></span><br><span class="line">       Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">       <span class="comment">// 若有接口，则创建目标对象的 JDK Proxy 对象</span></span><br><span class="line">       <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                   type.getClassLoader(),</span><br><span class="line">                   interfaces,</span><br><span class="line">                   <span class="keyword">new</span> Plugin(target, interceptor, signatureMap)); <span class="comment">// 因为 Plugin 实现了 InvocationHandler 接口，所以可以作为 JDK 动态代理的调用处理器</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果没有，则返回原始的目标对象</span></span><br><span class="line">       <span class="keyword">return</span> target;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过上面的源码，我们发现最终拦截器或者插件的实现原理就是通过<code>JDK动态代理</code>来实现的。</p><p><code>interceptorChain</code>保存了所有的拦截器(interceptors)，在Mybatis初始化的时候创建。<br>当创建四大对象时，调用拦截器链中的拦截器依次的对目标进行拦截或增强。<br><code>interceptor.plugin(target)</code>中的<code>target</code>就可以理解为要被拦截的四大对象。返回的<code>target</code>就是被重重代理后的对象。</p><p>这时候如果我们想要自定义一个插件，只需要实现Mybatis的<code>Interceptor</code>接口，重写其中的方法就行了，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta">        @Signature(type= StatementHandler.class,</span></span><br><span class="line"><span class="meta">                  method = &quot;prepare&quot;,</span></span><br><span class="line"><span class="meta">                  args = &#123;Connection.class,Integer.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只要被拦截的目标对象的目标方法被执行时，每次都会执行intercept方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对方法进行了增强....&quot;</span>);</span><br><span class="line">        <span class="comment">// 增强逻辑执行完毕后，原方法执行</span></span><br><span class="line">        <span class="keyword">return</span> invocation.proceed(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要为了把当前的拦截器生成代理存到拦截器链中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        Object wrap = Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> wrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取配置文件的参数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取到的配置文件的参数是：&quot;</span>+properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>@Intercepts</code>和<code>@Signature</code>注解，可以指定自定义的拦截器(插件)是在哪个类的哪个方法执行时进行拦截，可以定义多个<code>@Signature</code>，同时对多个方法进行拦截。</p><p>当然，插件开发完毕后，也不是直接就会生效，还需要将其配置到Mybatis的核心配置文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.jfl.test.plugin.MyPlugin&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置之后，在Mybatis启动时就会将这个插件放入<code>interceptorChain</code>中，最终生成代理对象完成增强的方法的执行。</p>]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习笔记-注解、延迟加载以及缓存</title>
      <link href="/2020/01/23/mybatis2/"/>
      <url>/2020/01/23/mybatis2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-mybatis注解"><a href="#1-mybatis注解" class="headerlink" title="1. mybatis注解"></a>1. mybatis注解</h2><blockquote><p>上一章介绍mybatis的使用时，主要介绍的是通过XML方式进行SQL相关配置，其实我们还可以通过注解来减少编写Mapper映射文件，本章就主要讲解相关的注解。</p></blockquote><h4 id="1-1-常用的CRUD注解"><a href="#1-1-常用的CRUD注解" class="headerlink" title="1.1 常用的CRUD注解"></a>1.1 常用的CRUD注解</h4><ul><li>@Insert：实现新增</li><li>@Update：实现更新</li><li>@Delete：实现删除</li><li>@Select：实现查询</li></ul><p>通过上面的注解，可以替代mapper.xml里面的相关SQL标签，例如通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>可以替代</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-2-结果集注解"><a href="#1-2-结果集注解" class="headerlink" title="1.2 结果集注解"></a>1.2 结果集注解</h4><p>在注解模式中，怎么指定返回的结果集中数据库字段与实体属性名的对应关系呢？<br>主要是通过<code>@Result和@Results</code>来实现，具体示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">   <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">           @Result(property = &quot;id&quot;,column = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">           @Result(property = &quot;name&quot;,column = &quot;name&quot;)</span></span><br><span class="line"><span class="meta">   &#125;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>其中的属性的解释：</p><ul><li>property：对应xml中resultMap的property属性，代表类属性名；</li><li>column：对象xml中resultMap的column属性，代表表字段名；</li><li>javaType：对应的java数据类型</li></ul><h4 id="1-3-复杂映射注解"><a href="#1-3-复杂映射注解" class="headerlink" title="1.3 复杂映射注解"></a>1.3 复杂映射注解</h4><p>复杂映射主要是分为一对一、一对多、多对多，通过上一章我们知道多对多就是两个一对多，所以此处只演示一对一和一对多两种情况。</p><h6 id="1-3-1-一对一"><a href="#1-3-1-一对一" class="headerlink" title="1.3.1 一对一"></a>1.3.1 一对一</h6><p>一对一的注解是<code>@One</code>,它代替了<code>&lt;association/&gt;</code>标签，来指定子查询返回的对象信息。其中的属性讲解：</p><ul><li>select：指定关联的查询方法的全限定方法名</li></ul><p>同时，<code>column</code>属性对应的<code>pid</code>值就是要传入子查询的参数。</p><p>通过上一章的用户和省信息的一对一例子来演示，通过注解实现时，等于是将查询拆分成两个，首先是查询用户、其次是查询省份信息。<br>所以我们需要在<code>ProvinceMapp.java</code>里定义查询<code>findById()</code>，提供给用户查询时调用，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">           @Result(property = &quot;id&quot;,column = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">           @Result(property = &quot;name&quot;,column = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">           @Result(property = &quot;province&quot;,column = &quot;pid&quot;,javaType = Province.class,</span></span><br><span class="line"><span class="meta">                   one=@One(select = &quot;com.jfl.test.mapper.ProvinceMapper.findById&quot;))</span></span><br><span class="line"><span class="meta">   &#125;)</span></span><br><span class="line">   <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserAndProvince</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>同时，在<code>ProvinceMapper.java</code>中提供如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&#123;&quot;select * from province where pid = #&#123;pid&#125;&quot;&#125;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Province <span class="title">findById</span><span class="params">(Integer pid)</span></span>;</span><br></pre></td></tr></table></figure><p>当进行用户查询时，同时将用户信息中的<code>pid</code>传入指定的省信息查询方法，最终返回用户和省信息的综合信息，完成一对一的查询。</p><h6 id="1-3-2-一对多"><a href="#1-3-2-一对多" class="headerlink" title="1.3.2 一对多"></a>1.3.2 一对多</h6><p>一对多的注解是<code>@Many</code>,它代替了<code>&lt;collection/&gt;</code>标签，来指定子查询返回的对象信息。其中的属性讲解：</p><ul><li>select：指定关联的查询方法的全限定方法名</li></ul><p>具体使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from province&quot;)</span></span><br><span class="line">   <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">           @Result(property = &quot;pid&quot;,column = &quot;pid&quot;),</span></span><br><span class="line"><span class="meta">           @Result(property = &quot;pname&quot;,column = &quot;pname&quot;),</span></span><br><span class="line"><span class="meta">           @Result(property = &quot;userList&quot;,column = &quot;pid&quot;,javaType = List.class,</span></span><br><span class="line"><span class="meta">               many=@Many(select = &quot;com.jfl.test.mapper.UserMapper.findUserByPid&quot;))</span></span><br><span class="line"><span class="meta">   &#125;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Province&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>同时，用户那变需要提供对应的查询方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user where pid = #&#123;pid&#125;&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Order&gt; <span class="title">findUserByPid</span><span class="params">(Integer pid)</span></span>;</span><br></pre></td></tr></table></figure><p>最终就会返回一对多的结果。<br>在使用上，一对多和一对一基本一样，只有注解以及返回结果类型的差异。</p><h2 id="2-延迟加载"><a href="#2-延迟加载" class="headerlink" title="2. 延迟加载"></a>2. 延迟加载</h2><blockquote><p>延迟加载就是在需要⽤到数据时才进⾏加载，不需要⽤到数据时就不加载数据。<br>延迟加载也称懒加载。<br>延迟加载是基于嵌套查询来实现的。<br>Mybatis是支持延迟加载的，只不过默认是关闭状态。</p></blockquote><p>在开发过程中，很多时候我们并不需要在加载省份信息时就⼀定要加载关联的用户信息。此时就是我们所说的延迟加载。<br>延迟加载分为局部延迟加载和全局延迟加载，主要是根据配置的位置不同，影响的范围不同。<br>延迟加载是基于嵌套查询来实现的，因为它是将关联的查询进行延迟查询来实现延迟加载，如果使用的是<code>left join</code>或者其他非嵌套的查询，是没法进行延迟加载。</p><h4 id="2-1-局部延迟加载"><a href="#2-1-局部延迟加载" class="headerlink" title="2.1 局部延迟加载"></a>2.1 局部延迟加载</h4><p>在<code>&lt;association/&gt;</code>和<code>&lt;collection/&gt;</code>标签中都有⼀个<code>fetchType</code>属性，通过修改它的值<code>lazy </code>还是<code>eager</code>，可以修改局部的加载策略。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.jfl.test.User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> fetchType=&quot;lazy&quot; : 懒加载策略</span></span><br><span class="line"><span class="comment"> fetchType=&quot;eager&quot; : ⽴即加载策略</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;province&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;province&quot;</span> <span class="attr">column</span>=<span class="string">&quot;pid&quot;</span> <span class="attr">select</span>=<span class="string">&quot;com.jfl.test.mapper.ProvinceMapper.findById&quot;</span> <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;pid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;pname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种情况下，只有这一个查询会进行延迟加载。</p><h4 id="2-2-全局延迟加载"><a href="#2-2-全局延迟加载" class="headerlink" title="2.2 全局延迟加载"></a>2.2 全局延迟加载</h4><p>想要全局的嵌套查询都进行延迟加载的话，在Mybatis的核⼼配置⽂件中可以使⽤<code>setting</code>标签修改全局的加载策略。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启全局延迟加载功能--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：加载策略的优先级是局部高于全局，也就类似于就近原则，如果sql上配置了立即加载，就算配了全局延迟的策略，但是在这个sql执行时也不会延迟加载。</strong></p><h4 id="2-3-延迟加载触发"><a href="#2-3-延迟加载触发" class="headerlink" title="2.3 延迟加载触发"></a>2.3 延迟加载触发</h4><p>当配置了延迟加载策略后，会发现即使没有调⽤关联对象的任何⽅法，但是在调⽤当前对象的equals、clone、hashCode、toString⽅法时也会触发关联对象的查询。<br>查看源码，可以看到在<code>org.apache.ibatis.session.Configuration</code>里默认触发中有这几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line">.......</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定对象的哪个方法会触发延迟加载。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Set&lt;String&gt; lazyLoadTriggerMethods = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">&quot;equals&quot;</span>, <span class="string">&quot;clone&quot;</span>, <span class="string">&quot;hashCode&quot;</span>, <span class="string">&quot;toString&quot;</span>));</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决这个问题，可以通过配置覆盖掉上诉的方法，具体配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启全局延迟加载功能--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--所有⽅法都会延迟加载--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-4-延迟加载原理"><a href="#2-4-延迟加载原理" class="headerlink" title="2.4 延迟加载原理"></a>2.4 延迟加载原理</h4><blockquote><p>其实底层是通过动态代理(默认使⽤Javassist代理⼯⼚)来实现的延迟加载</p></blockquote><p>当查询用户时，发现如果有懒加载的配置,如：<code>fetchType=&quot;lazy&quot;</code>，则将User生成一个代理对象进行返回，并把懒加载相关对象放到<code>ResultLoaderMap</code>中存起来，当调用到懒加载相关方法时，根据代理类的<code>invoke</code>进行具体的SQL查询，最终得到结果。<br>通过<code>org.apache.ibatis.session.Configuration</code>里的<code>setProxyFactory</code>方法可以看到默认情况下使用的是<code>JavassistProxyFactory</code>，部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 默认使⽤Javassist代理⼯⼚</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> proxyFactory</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProxyFactory</span><span class="params">(ProxyFactory proxyFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (proxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">proxyFactory = <span class="keyword">new</span> JavassistProxyFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.proxyFactory = proxyFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过追踪代码，可以看到Mybatis的查询结果是由<code>ResultSetHandler</code>接⼝的<code>handleResultSets()</code>⽅法处理的，所以可以进入它唯一的实现类<code>DefaultResultSetHandler</code>来查看具体逻辑，主要方法是<code>createResultObject</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建映射后的结果对象</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Object <span class="title">createResultObject</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultLoaderMap lazyLoader, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">       <span class="comment">// useConstructorMappings ，表示是否使用构造方法创建该结果对象。此处将其重置</span></span><br><span class="line">       <span class="keyword">this</span>.useConstructorMappings = <span class="keyword">false</span>; <span class="comment">// reset previous mapping result</span></span><br><span class="line">       <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; constructorArgTypes = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 记录使用的构造方法的参数类型的数组</span></span><br><span class="line">       <span class="keyword">final</span> List&lt;Object&gt; constructorArgs = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 记录使用的构造方法的参数值的数组</span></span><br><span class="line">       <span class="comment">// 创建映射后的结果对象</span></span><br><span class="line">       Object resultObject = createResultObject(rsw, resultMap, constructorArgTypes, constructorArgs, columnPrefix);</span><br><span class="line">       <span class="keyword">if</span> (resultObject != <span class="keyword">null</span> &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) &#123;</span><br><span class="line">           <span class="comment">// 如果有内嵌的查询，并且开启延迟加载，则创建结果对象的代理对象</span></span><br><span class="line">           <span class="keyword">final</span> List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();</span><br><span class="line">           <span class="keyword">for</span> (ResultMapping propertyMapping : propertyMappings) &#123;</span><br><span class="line">               <span class="comment">// issue gcode #109 &amp;&amp; issue #149</span></span><br><span class="line">               <span class="keyword">if</span> (propertyMapping.getNestedQueryId() != <span class="keyword">null</span> &amp;&amp; propertyMapping.isLazy()) &#123;</span><br><span class="line">                   resultObject = configuration.getProxyFactory().createProxy(resultObject, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 判断是否使用构造方法创建该结果对象</span></span><br><span class="line">       <span class="keyword">this</span>.useConstructorMappings = resultObject != <span class="keyword">null</span> &amp;&amp; !constructorArgTypes.isEmpty(); <span class="comment">// set current mapping result</span></span><br><span class="line">       <span class="keyword">return</span> resultObject;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过源码会看到在发现有延迟加载的属性时，会去调用<code>configuration.getProxyFactory().createProxy()</code>产生一个代理对象并返回，<code>configuration.getProxyFactory()</code>返回的就是上面说的默认代理对象工厂<code>JavassistProxyFactory</code>，然后调用工厂的<code>createProxy()</code>方法，查看源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">(Object target, ResultLoaderMap lazyLoader, Configuration configuration, ObjectFactory objectFactory, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> EnhancedResultObjectProxyImpl.createProxy(target, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>看到最终返回的是<code>EnhancedResultObjectProxyImpl</code>的相关返回的结果，看到这个名字可以得到使用的应该就是<code>cglib</code>的动态代理。进入该类中，可以看到具体的<code>cglib</code>的创建逻辑以及调用时会执行的<code>invoke</code>方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">crateProxy</span><span class="params">(Class&lt;?&gt; type, MethodHandler callback, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 javassist ProxyFactory 对象</span></span><br><span class="line">        ProxyFactory enhancer = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        <span class="comment">// 设置父类</span></span><br><span class="line">        enhancer.setSuperclass(type);</span><br><span class="line">        <span class="comment">// 根据情况，设置接口为 WriteReplaceInterface 。和序列化相关，可以无视</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            type.getDeclaredMethod(WRITE_REPLACE_METHOD); <span class="comment">// 如果已经存在 writeReplace 方法，则不用设置接口为 WriteReplaceInterface</span></span><br><span class="line">            <span class="comment">// ObjectOutputStream will call writeReplace of objects returned by writeReplace</span></span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(WRITE_REPLACE_METHOD + <span class="string">&quot; method was found on bean &quot;</span> + type + <span class="string">&quot;, make sure it returns this&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            enhancer.setInterfaces(<span class="keyword">new</span> Class[]&#123;WriteReplaceInterface.class&#125;); <span class="comment">// 如果不存在 writeReplace 方法，则设置接口为 WriteReplaceInterface</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            <span class="comment">// nothing to do here</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        Object enhanced;</span><br><span class="line">        Class&lt;?&gt;[] typesArray = constructorArgTypes.toArray(<span class="keyword">new</span> Class[constructorArgTypes.size()]);</span><br><span class="line">        Object[] valuesArray = constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            enhanced = enhancer.create(typesArray, valuesArray);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Error creating lazy proxy.  Cause: &quot;</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置代理对象的执行器</span></span><br><span class="line">        ((Proxy) enhanced).setHandler(callback);</span><br><span class="line">        <span class="keyword">return</span> enhanced;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到最终使用的是<code>enhancer.create</code>，所以可以确定是<code>cglib</code>动态代理来产生代理对象。<br>再查看下<code>invoke</code>方法，看具体是怎么执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FINALIZE_METHOD = <span class="string">&quot;finalize&quot;</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WRITE_REPLACE_METHOD = <span class="string">&quot;writeReplace&quot;</span>;</span><br><span class="line">   </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object enhanced, Method method, Method methodProxy, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   <span class="comment">// 得到执行的方法名</span></span><br><span class="line">       <span class="keyword">final</span> String methodName = method.getName();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (lazyLoader) &#123;</span><br><span class="line">           <span class="comment">// 不匹配，直接进入else</span></span><br><span class="line">               <span class="keyword">if</span> (WRITE_REPLACE_METHOD.equals(methodName)) &#123;</span><br><span class="line">                   Object original;</span><br><span class="line">                   <span class="comment">// 判断构造函数是否无参</span></span><br><span class="line">                   <span class="keyword">if</span> (constructorArgTypes.isEmpty()) &#123;</span><br><span class="line">                       original = objectFactory.create(type);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       original = objectFactory.create(type, constructorArgTypes, constructorArgs);</span><br><span class="line">                   &#125;</span><br><span class="line">                   PropertyCopier.copyBeanProperties(type, enhanced, original);</span><br><span class="line">                   <span class="keyword">if</span> (lazyLoader.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">new</span> JavassistSerialStateHolder(original, lazyLoader.getProperties(), objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="keyword">return</span> original;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 是否有延迟加载</span></span><br><span class="line">                   <span class="keyword">if</span> (lazyLoader.size() &gt; <span class="number">0</span> &amp;&amp; !FINALIZE_METHOD.equals(methodName)) &#123;</span><br><span class="line">                       <span class="comment">// 加载所有延迟加载的属性</span></span><br><span class="line">                       <span class="keyword">if</span> (aggressive || lazyLoadTriggerMethods.contains(methodName)) &#123;</span><br><span class="line">                           lazyLoader.loadAll();</span><br><span class="line">                       <span class="comment">// 如果调用了 setting 方法，则不在使用延迟加载</span></span><br><span class="line">                       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PropertyNamer.isSetter(methodName)) &#123;</span><br><span class="line">                           <span class="keyword">final</span> String property = PropertyNamer.methodToProperty(methodName);</span><br><span class="line">                           lazyLoader.remove(property); <span class="comment">// 移除</span></span><br><span class="line">                       <span class="comment">// 如果调用了 getting 方法，则执行延迟加载</span></span><br><span class="line">                       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PropertyNamer.isGetter(methodName)) &#123;</span><br><span class="line">                           <span class="keyword">final</span> String property = PropertyNamer.methodToProperty(methodName);</span><br><span class="line">                           <span class="keyword">if</span> (lazyLoader.hasLoader(property)) &#123;</span><br><span class="line">                           <span class="comment">// 延迟加载单个属性</span></span><br><span class="line">                               lazyLoader.load(property);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 继续执行原方法</span></span><br><span class="line">           <span class="keyword">return</span> methodProxy.invoke(enhanced, args);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过以上源码分析，可以印证最开始所讲的，通过动态代理来实现的延迟加载。</p><h2 id="3-缓存机制"><a href="#3-缓存机制" class="headerlink" title="3. 缓存机制"></a>3. 缓存机制</h2><blockquote><p>mybatis的缓存分为一级缓存和二级缓存；<br>一级缓存默认开启，二级缓存默认关闭<br>二级缓存会引起脏读，所以不建议使用，常用redis做数据缓存</p></blockquote><h4 id="3-1-一级缓存"><a href="#3-1-一级缓存" class="headerlink" title="3.1 一级缓存"></a>3.1 一级缓存</h4><p>一级缓存的有效范围是同一个sqlSession；同一个sqlSession中执行相同的查询，第二次查询不会访问数据库，直接从一级缓存获取，返回给调用者。<br>但是如果两次查询中间有增删改操作，则会刷新一级缓存，这时第二次查询依然会去查询数据库。<br>通过分析源码，可以知道<code>一级缓存的数据结构就是一个HashMap</code>：<br><img src="https://img-blog.csdnimg.cn/20201022165105302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xmajM5NzQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>，而这个map的key就是mapperstatement（保存了要执行的SQL的信息）、参数、分页信息、最终执行的SQL来组成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为本次查询创建缓存的Key</span></span><br><span class="line">   CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br></pre></td></tr></table></figure><p>所以每一个SqISession都会存放一个map对象的引用，那什么时候会创建一级缓存的Map呢，通过源码分析得知是通过<code>BaseExecutor</code>来创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">BaseExecutor</span><span class="params">(Configuration configuration, Transaction transaction)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.transaction = transaction;</span><br><span class="line">       <span class="keyword">this</span>.deferredLoads = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">       <span class="comment">// 创建本地缓存</span></span><br><span class="line">       <span class="keyword">this</span>.localCache = <span class="keyword">new</span> PerpetualCache(<span class="string">&quot;LocalCache&quot;</span>);</span><br><span class="line">       <span class="keyword">this</span>.localOutputParameterCache = <span class="keyword">new</span> PerpetualCache(<span class="string">&quot;LocalOutputParameterCache&quot;</span>);</span><br><span class="line">       <span class="keyword">this</span>.closed = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">       <span class="keyword">this</span>.wrapper = <span class="keyword">this</span>; <span class="comment">// 自己</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>当执行查询的时候，就会先去缓存中取，如果取不到再走查询，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">       ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">       <span class="comment">// 已经关闭，则抛出 ExecutorException 异常</span></span><br><span class="line">       <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 清空本地缓存，如果 queryStack 为零，并且要求清空本地缓存。</span></span><br><span class="line">       <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">           clearLocalCache();</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;E&gt; list;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// queryStack + 1</span></span><br><span class="line">           queryStack++;</span><br><span class="line">           <span class="comment">// 从一级缓存中，获取查询结果</span></span><br><span class="line">           list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// 获取到，则进行处理</span></span><br><span class="line">           <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">               handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">           <span class="comment">// 获得不到，则从数据库中查询</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// queryStack - 1</span></span><br><span class="line">           queryStack--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 执行延迟加载</span></span><br><span class="line">           <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">               deferredLoad.load();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// issue #601</span></span><br><span class="line">           <span class="comment">// 清空 deferredLoads</span></span><br><span class="line">           deferredLoads.clear();</span><br><span class="line">           <span class="comment">// 如果缓存级别是 LocalCacheScope.STATEMENT ，则进行清理</span></span><br><span class="line">           <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">               <span class="comment">// issue #482</span></span><br><span class="line">               clearLocalCache();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>缓存中如果查不到的话，就从数据库查，在<code>queryFromDatabase</code>方法中，会将查询结果写入localcache，内部调用的是Map的put方法，最终交给Map进行存放。</p><h4 id="3-2-二级缓存"><a href="#3-2-二级缓存" class="headerlink" title="3.2 二级缓存"></a>3.2 二级缓存</h4><p>二级缓存的原理和数据结构，和一级缓存是一样的，不过二级缓存的作用范围是基于mapper文件的namespace的，也就是说多个sqlSession可以共享一个mapper中的二级缓存区域，并且如果多个mapper的namespace相同，即使是两个mapper，那么这两个mapper中执行sql查询到的数据也将存在相同的二级缓存区域中。<br>由于二级缓存默认是关闭，如果打开需要进行配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其次在Mapper.xml文件中开启缓存：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure><p>空标签说明使用mybatis自身的二级缓存，也可以进行指定：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.redis.RedisCache&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这个就是指定使用redis作为二级缓存。<br>使用二级缓存需要pojo实现Serializable接口，为了将缓存数据取出执行反序列化操作，因为二级缓存数据存储介质多种多样，不一定只存在内存中，有可能存在硬盘中，如果我们要再取这个缓存的话，就需要反序列化了。</p><p>上面描述的是全局的配置，如果单独开启，则在sql标签上使用<code>userCache</code>和<code>flushCache</code>等配置项，useCache为true则使用二级缓存，否则不使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByUserId&quot;</span> <span class="attr">useCache</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">resultType</span>=<span class="string">&quot;com.jfl.test.pojo.User&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">select * from user where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置<code>flushCache=&quot;true”</code>则会在增删改之后刷新缓存，默认是true，如果不刷新，则会出现脏读等问题。</p><h4 id="3-3-redis做为二级缓存"><a href="#3-3-redis做为二级缓存" class="headerlink" title="3.3 redis做为二级缓存"></a>3.3 redis做为二级缓存</h4><p>使用mybatis自带的二级缓存存在以下问题：</p><ul><li>自带的二级缓存是单服务器工作，无法实现分布式缓存；</li><li>当进行嵌套查询时，A表关联的B表数据，通过A查询时，最终结果是存在A的二级缓存中，当B发生改变，A的二级缓存是不会进行刷新的，会导致脏读等问题；</li></ul><p>所以尽可能的不使用自带的二级缓存，而redis就是一个很好的分布式缓存，所以一般都是使用redis来做缓存。<br>主要的原理是redis提供的缓存，实现了mybatis的Cache接口，在配置时可以指定具体实现类，来使用redis的缓存。<br>mybatis-redis在存储数据的时候，是使用的hash结构，把cache的id作为这个hash的key (cache的id在mybatis中就是mapper的namespace)；这个mapper中的查询缓存数据作为 hash的field，需要缓存的内容直接使用SerializeUtil存储，SerializeUtil和其他的序列化类差不多，负责对象的序列化和反序列化；</p>]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习笔记-基本概念和复杂映射</title>
      <link href="/2020/01/22/mybatis1/"/>
      <url>/2020/01/22/mybatis1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><blockquote><p>MyBatis是一款优秀的基于ORM的半自动轻量级持久层框架，它支持定制化SQL、存储过程以及高级映射，使用XML或注解实现映射对应，结果集自动转换成指定类型，无需自己处理。</p></blockquote><h4 id="1-1-什么是ORM"><a href="#1-1-什么是ORM" class="headerlink" title="1.1 什么是ORM"></a>1.1 什么是ORM</h4><p>ORM全称Object/Relation Mapping：表示对象-关系映射的缩写，它完成面向对象的编程语言到关系数据库的映射。<br>采用ORM框架后，应用程序不再直接访问底层数据库，而是以面向对象的方式来操作持久化对象，而ORM框架则将这些面向对象的操作转换成底层SQL操作。<br>ORM框架实现的效果：把对持久化对象的保存、修改、删除等操作，转换为对数据库的insert、update、delete操作。</p><h4 id="1-2-什么是半自动"><a href="#1-2-什么是半自动" class="headerlink" title="1.2 什么是半自动"></a>1.2 什么是半自动</h4><p>简单来说，半自动就是还需要开发人员自己写核心的SQL。<br>与之对应的就是全自动，类似Hibernate等，就是无需写SQL都是全自动完成。</p><h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2. 配置文件"></a>2. 配置文件</h3><blockquote><p>Mybatis的配置文件一般分为两种，一个是核心配置文件，一个是映射配置文件，<br>核心配置文件配置了Mybatis的核心配置，包括数据库连接信息、是否开启缓存等；<br>映射配置文件主要是用于配置具体的映射关系的文件；</p></blockquote><h4 id="2-1-核心配置文件"><a href="#2-1-核心配置文件" class="headerlink" title="2.1 核心配置文件"></a>2.1 核心配置文件</h4><p>Mybatis的核心配置文件一般我们命名为sqlMapConfig.xml，里面配置了相关的标签，来指定一些操作（标签是存在顺序的，如果顺序写错，会有提示），具体概述如下：</p><ul><li><code>&lt;configration/&gt;</code>：顶层配置标签</li><li><code>&lt;properties/&gt;</code>：加载额外配置的properties文件</li><li><code>&lt;setting/&gt;</code>:全局配置，例如是否使用缓存、超时时间设置等</li><li><code>&lt;typeAliases/&gt;</code>：类型别名，给parameterType或者ResultType定义别名</li><li><code>&lt;typeHandlers/&gt;</code>：类型处理器，配置将sql返回的数据库类型转换为相应Java类型的处理器</li><li><code>&lt;objectFactory/&gt;</code>：对象工厂，可以继承DefaultObjectFactory来定义对象工厂</li><li><code>&lt;plugins/&gt;</code>：插件，其实就是拦截器，通过实现Interceptor接口，并添加Intercepts注解（里面可以定义多个signature去拦截多个方法）</li><li><code>&lt;environments/&gt;</code>：环境，里面可以定义多个环境变量（环境变量中可以指定事务、数据源等信息），由default来指定默认使用那个</li><li><code>&lt;databaseIdProvider/&gt;</code>：数据库厂商标识</li><li><code>&lt;mappers/&gt;</code>：需要加载的映射配置文件（可以通过package或者resource、url、class来加载一个或多个映射配置文件）</li></ul><h4 id="2-2-映射配置文件"><a href="#2-2-映射配置文件" class="headerlink" title="2.2 映射配置文件"></a>2.2 映射配置文件</h4><p>在映射配置文件中，常用的标签如下：</p><ul><li><code>&lt;resultMap/&gt;</code>来指定数据库字段名和实体类属性的对应关系。</li><li><code>&lt;parameterType/&gt;</code>：参数类型</li><li><code>&lt;resultType/&gt;或&lt;resultMap/&gt;</code>：结果类型或者使用的结果集</li><li><code>&lt;select/&gt; &lt;insert/&gt; &lt;update/&gt; &lt;delete/&gt;</code>：定义增删改查的SQL语句</li></ul><p>常用的动态标签：</p><ul><li>where：使用该标签会自动去除第一个and，不需要写where 1=1</li><li>if：根据参数对象的取值进行不同条件的判断</li><li>foreach：进行数组的循环，通过open和close属性，生成类似 id in ()或者对map进行遍历</li><li>include：进行SQL片段抽取，避免同样的SQL的重复编写</li><li>choose、when、otherwise：进行条件判断，如果不符合就是要otherwise（相当于default）</li></ul><h3 id="3-复杂映射"><a href="#3-复杂映射" class="headerlink" title="3. 复杂映射"></a>3. 复杂映射</h3><blockquote><p>复杂映射，主要是为了解决一对一、一对多、多对多的映射关系</p></blockquote><h4 id="2-1-一对一"><a href="#2-1-一对一" class="headerlink" title="2.1 一对一"></a>2.1 一对一</h4><p>在此举例说明，现有两张表，一张用户表User，一张省信息表province。<br>一个人属于一个省，当查询User信息时，也要将所属的省信息查出，这时就符合所说的一对一映射查询。<br>如果通过SQL完成查询，对应的sql语句应该是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> u.name, p.pname <span class="keyword">from</span> province p,<span class="keyword">user</span> u <span class="keyword">where</span> u.pid<span class="operator">=</span>p.pid;</span><br></pre></td></tr></table></figure><p>反应在Java实体上，就是<code>User</code>类中，会声明一个<code>Province</code>的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long uid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Province province;</span><br><span class="line">........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在如果通过XML方式想要在查询用户时将省信息同时查出，需要用到<code>&lt;association/&gt;</code>标签。UserMapper.xml中的resultMap需要增加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.jfl.test.User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明一对一相关信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;province&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.jfl.test.Province&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;pid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;pname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中<code>&lt;association/&gt;</code>的property属性对应实体中的属性名，里面的标签对应Province的属性。<br>此时查询结果就是如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User&#123;id=<span class="number">1</span>,name=<span class="string">&#x27;tom&#x27;</span>,province=Province&#123;pid=<span class="number">1</span>,pname=<span class="string">&#x27;beijing&#x27;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-一对多"><a href="#2-2-一对多" class="headerlink" title="2.2 一对多"></a>2.2 一对多</h4><p>还是上面的例子，一个省对应多个人，这种情况下想要查询一对多，通过SQL查询的话，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> p.pid,p.pname,u.id,u.name <span class="keyword">from</span> province p <span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> u.pid<span class="operator">=</span>p.pid;</span><br></pre></td></tr></table></figure><p>反应在Java实体上，就是<code>Province</code>类中，会声明一个<code>List&lt;User&gt;</code>的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Province</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long pid;</span><br><span class="line">    <span class="keyword">private</span> String pname;</span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; userList;</span><br><span class="line">........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而mybatis的映射配置XML文件中，需要增加<code>&lt;collection /&gt;</code>配置，才可以支持一对多：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;provinceMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.jfl.test.Province&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;pid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;pname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;userList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.jfl.test.User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-多对多"><a href="#2-3-多对多" class="headerlink" title="2.3 多对多"></a>2.3 多对多</h4><p>此处举例说明，一个学生学习多门课程，每门课程也有很多学生来学习。此时学生和课程的对应关系就是多对多，通常这种情况，在数据库设计时会通过中间表来实现，模型如下图：<br><img src="https://img-blog.csdnimg.cn/20201022143803542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xmajM5NzQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>此时就可以将学生和课程的多对多，看成是学生表和学生课程关系表的一对多；同理，课程和学生的关系，也可以看成是课程表和学生课程关系表的一对多。<br>所以多对多，其实就是两个一对多，具体实现参考一对多。</p>]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
