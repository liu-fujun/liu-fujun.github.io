<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于RBAC实现的方案记录-下</title>
      <link href="/2022/01/25/rbac2/"/>
      <url>/2022/01/25/rbac2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RBAC </tag>
            
            <tag> 权限 </tag>
            
            <tag> 角色 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于RBAC实现的方案记录-上</title>
      <link href="/2022/01/23/rbac1/"/>
      <url>/2022/01/23/rbac1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是RBAC"><a href="#1-什么是RBAC" class="headerlink" title="1. 什么是RBAC"></a>1. 什么是RBAC</h2><p>RBAC，全称是 Role-Based Access Control ，也就是基于角色的访问控制。<br><br>RBAC认为权限授权的过程可以抽象地概括为：<code>Who是否可以对What进行How的访问操作，并对这个逻辑表达式进行判断是否为True的求解过程</code>。也即是将权限问题转换为What、How的问题.<br><br>Who、What、How构成了访问权限三元组。</p><h2 id="2-为什么需要RBAC"><a href="#2-为什么需要RBAC" class="headerlink" title="2. 为什么需要RBAC"></a>2. 为什么需要RBAC</h2><h3 id="2-1-原始权限控制"><a href="#2-1-原始权限控制" class="headerlink" title="2.1 原始权限控制"></a>2.1 原始权限控制</h3><p>在没有RBAC的时候，如果需要对用户授权，则需要直接将权限授予客户，如下图：<br><img src="/2022/01/23/rbac1/img.png" alt="u-p.png"></p><p>张三可以管理商品，同时可以对商品进行审核；<br><br>李四只能管理商品，无法审核；<br></p><p>对于这种情况存在以下问题：</p><ol><li>当用户数量很多的时候，需要对每一个用户执行授权操作；</li><li>当权限新增或者删除的时候，也是需要每个用户单独执行；</li><li>当想要快速去除某一部分人的某一部分权限时，操作复杂；</li></ol><h3 id="2-2-RBAC"><a href="#2-2-RBAC" class="headerlink" title="2.2 RBAC"></a>2.2 RBAC</h3><p>针对传统模式的情况，RBAC通过它的权限三元组进行了解决，如图：<br><img src="/2022/01/23/rbac1/img2.png" alt="u-r-p.png"></p><p>在RBAC模型里面，有3个基础组成部分，分别是：用户、角色和权限。<br><br>通过增加角色，权限与角色进行关联，同时用户与角色进行关联，来解决上面的问题。</p><ol><li>当新增用户时，只需要关联角色，即可获得指定的权限；</li><li>当角色与权限发生变化时，所有关联此角色的用户都会受到影响；</li></ol><h3 id="2-3-RBAC的安全原则"><a href="#2-3-RBAC的安全原则" class="headerlink" title="2.3 RBAC的安全原则"></a>2.3 RBAC的安全原则</h3><ol><li>最小权限原则：RBAC可以将角色配置成其完成任务所需的最小权限集合；</li><li>责任分离原则：可以通过调用相互独立互斥的角色来共同完成敏感的任务；</li><li>数据抽象原则：可以通过权限的抽象来体现，例如资源操作等抽象权限，而不是使用典型的读、写、执行权限；</li></ol><h2 id="3-RBAC模型"><a href="#3-RBAC模型" class="headerlink" title="3. RBAC模型"></a>3. RBAC模型</h2><h3 id="3-1-RBAC0"><a href="#3-1-RBAC0" class="headerlink" title="3.1 RBAC0"></a>3.1 RBAC0</h3><p>RBAC0其实就是上面举的例子，是最简单的实现方式，也是其他RBAC的基础和核心。<br><br>在RBAC0中，用户角色权限三者关系如下图：<br><img src="/2022/01/23/rbac1/img3.png" alt="rbac.png"><br>一个用户可以关联多个角色，一个角色可以关联多个用户。<br><br>一个角色可以关联多个权限，一个权限可以关联多个角色。<br><br>即都为多对多的关联关系。<br></p><p>一般这种模型对应的数据库表关系如下：<br><img src="/2022/01/23/rbac1/sql.png" alt="table.png"></p><p>常见的就是5张表，用户表、角色表、权限表、用户角色关系表、角色权限关系表；</p><h3 id="3-2-RBAC1"><a href="#3-2-RBAC1" class="headerlink" title="3.2 RBAC1"></a>3.2 RBAC1</h3><p>RBAC1是基于RBAC0模型，引入了角色间的继承关系，即角色上有了上下级的区别。<br><br>可以给角色分组分层。</p><h3 id="3-3-RBAC2"><a href="#3-3-RBAC2" class="headerlink" title="3.3 RBAC2"></a>3.3 RBAC2</h3><p>RBAC2是基于RBAC0模型的基础上，进行了角色的访问控制。<br></p><ul><li>比如设置互斥角色，实现责任分离，互斥的角色不能分配给统一用户；</li><li>比如基数约束，即角色可以分配的用户数量受限，或者角色对权限数目受限等；</li></ul><h3 id="3-4-RBAC3"><a href="#3-4-RBAC3" class="headerlink" title="3.4 RBAC3"></a>3.4 RBAC3</h3><p>RBAC3其实就是将RBAC1和RBAC2两个模型进行结合。</p>]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RBAC </tag>
            
            <tag> 权限 </tag>
            
            <tag> 角色 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习笔记-手写简单的Mybatis</title>
      <link href="/2020/01/23/mybatis4/"/>
      <url>/2020/01/23/mybatis4/</url>
      
        <content type="html"><![CDATA[<h2 id="1-传统的JDBC模式"><a href="#1-传统的JDBC模式" class="headerlink" title="1. 传统的JDBC模式"></a>1. 传统的JDBC模式</h2><p>在没有使用ORM框架时，我们基本都是通过JDBC进行数据库的操作，一般的逻辑代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Connection connection = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement preparedStatement = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加载数据库驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过驱动管理类获取数据库链接</span></span><br><span class="line">        connection = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?</span></span><br><span class="line"><span class="string">characterEncoding=utf-8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="comment">// 定义sql语句？表示占位符</span></span><br><span class="line">        String sql = <span class="string">&quot;select * from user where username = ?&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取预处理statement</span></span><br><span class="line">        preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">        <span class="comment">// 设置参数，第一个参数为sql语句中参数的序号(从1开始)，第二个参数为设置的参数值</span></span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        <span class="comment">// 向数据库发出sql执行查询，查询出结果集</span></span><br><span class="line">        resultSet = preparedStatement.executeQuery();</span><br><span class="line">        <span class="comment">// 遍历查询结果集</span></span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = resultSet.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            String username = resultSet.getString(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">            <span class="comment">// 封装User</span></span><br><span class="line">            user.setId(id);</span><br><span class="line">            user.setUsername(username);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (preparedStatement != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                preparedStatement.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对JDBC的代码进行分析，可以发现存在以下问题：</p><ol><li>数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能；</li><li>Sql语句在代码中硬编码，造成代码不易维护，实际应用中sql变化的可能较大，sql变动需要改变java代码；</li><li>使用<code>preparedStatement</code>向占位符传参存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护；</li><li>对结果集解析存在硬编码(查询列名)，sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便；</li></ol><p>由于硬编码可以通过配置文件解决，针对上述的问题，所以我们可以想到如下的解决思路：</p><ol><li>使用数据库连接池初始化连接资源；</li><li>将sql语句抽取到xml配置文件中；</li><li>使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射；</li></ol><p>根据上述的思路进行自定义的Mybatis框架编写。</p><h2 id="2-客户端开发"><a href="#2-客户端开发" class="headerlink" title="2. 客户端开发"></a>2. 客户端开发</h2><p>首先客户端要提供数据库的连接信息以及SQL的信息。<br>根据设计思路，这些信息通过配置文件来解决，所以在<code>resources</code>目录下创建<code>sqlMapConfig.xml</code>文件，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库配置信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个文件中配置了要加载那些mapper.xml，这样只需要加载一次就完成了所有的加载。<br>在同个目录下创建映射配置文件<code>UserMapper.xml</code>，并定义了简单的增删改查的SQL。内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.ormtest.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.ormtest.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOne&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.ormtest.pojo.User&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.ormtest.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;id&#125; and username = #&#123;username&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--添加用户--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.ormtest.pojo.User&quot;</span> &gt;</span></span><br><span class="line">        insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--修改--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.ormtest.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        update user set username = #&#123;username&#125; where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--删除--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">        delete from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时也要生成对应的POJO对象，并定义Dao层接口，代码简单，此处就不粘贴了。<br>到此为止，客户的代码就编写完成了，等完成框架的编写之后，就可以进行测试了。</p><h2 id="3-自定义框架开发"><a href="#3-自定义框架开发" class="headerlink" title="3. 自定义框架开发"></a>3. 自定义框架开发</h2><p>开发的时候，我们根据逻辑流程一步步进行。</p><p>首先我们需要一个类来接受和加载核心配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将xml配置文件加载成为字节流</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InputStream <span class="title">getResourceAsSteam</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        InputStream resourceAsStream = Resources.class.getClassLoader().getResourceAsStream(path);</span><br><span class="line">        <span class="keyword">return</span> resourceAsStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心配置文件加载完成之后，就需要对字节流进行解析，所以声明一个解析xml的类，最终这个类要返回一个SqlSessionFactory的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionFactoryBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用构造器模式，将复杂对象进行逐步构建</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 使用dom4j读取字节流（也就是核心配置文件）的内容</span></span><br><span class="line">        <span class="comment">// 封装成一个configuration对象</span></span><br><span class="line">        XMLConfigBuilder xmlConfigBuilder = <span class="keyword">new</span> XMLConfigBuilder();</span><br><span class="line">        Configuration configuration = xmlConfigBuilder.parseConfig(in);</span><br><span class="line">        <span class="comment">// 根据配置信息创建sqlSession的工厂</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> DefaultSqlSessionFactory(configuration);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个解析的过程中，声明了一些解析类，比如<code>XMLConfigBuilder</code>进行核心配置文件的解析，里面还嵌套调用了<code>mapper.xml</code>的解析类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLConfigBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DRIVER = <span class="string">&quot;driver&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JDBCURL = <span class="string">&quot;jdbcUrl&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME = <span class="string">&quot;username&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">&quot;password&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XMLConfigBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过dom4j进行字节流解析</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Configuration <span class="title">parseConfig</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> DocumentException, PropertyVetoException </span>&#123;</span><br><span class="line">        <span class="comment">// 借助dom4j，进行解析，得到整个的文档对象</span></span><br><span class="line">        Document document = <span class="keyword">new</span> SAXReader().read(inputStream);</span><br><span class="line">        <span class="comment">// 得到根对象，即configuration标签</span></span><br><span class="line">        Element rootElement = document.getRootElement();</span><br><span class="line">        <span class="comment">// 获取property标签，进行数据库连接信息的解析加载</span></span><br><span class="line">        List&lt;Element&gt; elementList = rootElement.selectNodes(<span class="string">&quot;//property&quot;</span>);</span><br><span class="line">        <span class="comment">// 借助properties对象，进行属性保存</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">for</span> (Element element : elementList) &#123;</span><br><span class="line">            String name = element.attributeValue(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            String value = element.attributeValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">            properties.setProperty(name, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行数据库连接信息封装，使用C3P0连接池</span></span><br><span class="line">        ComboPooledDataSource comboPooledDataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">        comboPooledDataSource.setDriverClass(properties.getProperty(DRIVER));</span><br><span class="line">        comboPooledDataSource.setJdbcUrl(properties.getProperty(JDBCURL));</span><br><span class="line">        comboPooledDataSource.setUser(properties.getProperty(USERNAME));</span><br><span class="line">        comboPooledDataSource.setPassword(properties.getProperty(PASSWORD));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据源进行保存</span></span><br><span class="line">        configuration.setDataSource(comboPooledDataSource);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行mapper.xml的解析工作</span></span><br><span class="line">        <span class="comment">// 首先得到需要加载的xml</span></span><br><span class="line">        List&lt;Element&gt; mappers = rootElement.selectNodes(<span class="string">&quot;//mapper&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Element element : mappers) &#123;</span><br><span class="line">            <span class="comment">// 得到需要加载的mapper文件路径</span></span><br><span class="line">            String mapperPath = element.attributeValue(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">            <span class="comment">// 对mapper文件进行解析，得到mapperstatement</span></span><br><span class="line">            InputStream resourceAsSteam = Resources.getResourceAsSteam(mapperPath);</span><br><span class="line">            XMLMapperBuilder xmlMapperBuilder = <span class="keyword">new</span> XMLMapperBuilder(configuration);</span><br><span class="line">            xmlMapperBuilder.parseMapper(resourceAsSteam);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回整体配置对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.configuration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过解析<code>mapper.xml</code>，生成对应的<code>mappedStatement</code>对象，存入<code>Configuration</code>对象中，因为全局只有一个<code>Configuration</code>对象，所以每次都把这个对象进行传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLMapperBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XMLMapperBuilder</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用dom4j解析mapper.xml</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseMapper</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> DocumentException </span>&#123;</span><br><span class="line">        Document document = <span class="keyword">new</span> SAXReader().read(inputStream);</span><br><span class="line">        Element rootElement = document.getRootElement();</span><br><span class="line">        <span class="comment">// 得到当前mapper的namespace</span></span><br><span class="line">        String namespace = rootElement.attributeValue(<span class="string">&quot;namespace&quot;</span>);  </span><br><span class="line">        <span class="comment">//递归遍历当前节点所有的子节点</span></span><br><span class="line">        List&lt;Element&gt; elementList = rootElement.elements();</span><br><span class="line">        <span class="keyword">for</span> (Element element : elementList) &#123;</span><br><span class="line">            String id = element.attributeValue(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            String resultType = element.attributeValue(<span class="string">&quot;resultType&quot;</span>);</span><br><span class="line">            String parameterType = element.attributeValue(<span class="string">&quot;parameterType&quot;</span>);</span><br><span class="line">            String sqlText = element.getTextTrim();</span><br><span class="line">            MappedStatement mappedStatement = <span class="keyword">new</span> MappedStatement();</span><br><span class="line">            mappedStatement.setId(id);</span><br><span class="line">            mappedStatement.setResultType(resultType);</span><br><span class="line">            mappedStatement.setParameterType(parameterType);</span><br><span class="line">            mappedStatement.setSql(sqlText);</span><br><span class="line">            <span class="comment">// 增加sql类型字段</span></span><br><span class="line">            mappedStatement.setSqlCommandType(element.getName());</span><br><span class="line">            <span class="comment">// mapper的namespace和SQL语句的id，组成唯一id</span></span><br><span class="line">            String key = namespace+<span class="string">&quot;.&quot;</span>+id;</span><br><span class="line">            configuration.getMappedStatementMap().put(key,mappedStatement);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，所有的配置文件都加载完成，最终根据生成的<code>Configuration</code>对象，返回对应的<code>SqlSessionFactory</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSessionFactory</span> <span class="keyword">implements</span> <span class="title">SqlSessionFactory</span></span>&#123;</span><br><span class="line">    <span class="comment">// 通过构造方法注入，保证从上到下只有一个configuration对象</span></span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSessionFactory</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当客户端调用<code>openSession</code>方法时，就会返回一个<code>SqlSession</code>对象，该对象里面封装了增删改查的方法，供客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSession</span> <span class="keyword">implements</span> <span class="title">SqlSession</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSession</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doQuery</span><span class="params">(String statementId, <span class="keyword">boolean</span> resultTypeFlag, Object... params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 根据statementId得到要执行的SQL对象</span></span><br><span class="line">        MappedStatement mappedStatement = configuration.getMappedStatementMap().get(statementId);</span><br><span class="line">        <span class="comment">// 判断当前的SQL类型是什么</span></span><br><span class="line">        <span class="keyword">switch</span> (mappedStatement.getSqlCommandType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;select&quot;</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (resultTypeFlag) &#123;</span><br><span class="line">                    <span class="keyword">return</span> selectList(statementId, params);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> selectOne(statementId, params);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;insert&quot;</span>:&#123;</span><br><span class="line">                <span class="keyword">return</span> insert(statementId, params);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;update&quot;</span>:&#123;</span><br><span class="line">                <span class="keyword">return</span> update(statementId, params);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;delete&quot;</span>:&#123;</span><br><span class="line">                <span class="keyword">return</span> delete(statementId, params);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statementId, Object... params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 根据statementId得到要执行的SQL对象</span></span><br><span class="line">        MappedStatement mappedStatement = configuration.getMappedStatementMap().get(statementId);</span><br><span class="line">        Executor executor = <span class="keyword">new</span> SimpleExecutor();</span><br><span class="line">        List&lt;Object&gt; result = executor.query(configuration, mappedStatement, params);</span><br><span class="line">        <span class="keyword">return</span> (List&lt;E&gt;) result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statementId, Object... params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Object&gt; objects = <span class="keyword">this</span>.selectList(statementId, params);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == objects.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) objects.get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;查询结果为空或查询结果过多&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(String statementId, Object... params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MappedStatement mappedStatement = configuration.getMappedStatementMap().get(statementId);</span><br><span class="line">        Executor executor = <span class="keyword">new</span> SimpleExecutor();</span><br><span class="line">        executor.updateDatabase(configuration, mappedStatement, params);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String statementId, Object... params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MappedStatement mappedStatement = configuration.getMappedStatementMap().get(statementId);</span><br><span class="line">        Executor executor = <span class="keyword">new</span> SimpleExecutor();</span><br><span class="line">        executor.updateDatabase(configuration, mappedStatement, params);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(String statementId, Object... params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MappedStatement mappedStatement = configuration.getMappedStatementMap().get(statementId);</span><br><span class="line">        Executor executor = <span class="keyword">new</span> SimpleExecutor();</span><br><span class="line">        executor.updateDatabase(configuration, mappedStatement, params);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据JDK动态代理生成代理对象，对方法进行加工</span></span><br><span class="line">        Object proxyInstance = Proxy.newProxyInstance(DefaultSqlSession.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;mapperClass&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// 这里无法获取mapper.xml的信息，所以为了方便识别，需要将namespace和SQL语句的id与接口的全限定名和方法保持一致</span></span><br><span class="line">                <span class="comment">// 获取方法名</span></span><br><span class="line">                String methodName = method.getName();</span><br><span class="line">                <span class="comment">// 获取所属的接口class名称</span></span><br><span class="line">                String className = method.getDeclaringClass().getName();</span><br><span class="line">                <span class="comment">// 得到唯一的statementId</span></span><br><span class="line">                String statementId = className + <span class="string">&quot;.&quot;</span> + methodName;</span><br><span class="line">                <span class="comment">// 根据方法的返回结果类型进行判断</span></span><br><span class="line">                Type genericReturnType = method.getGenericReturnType();</span><br><span class="line">                <span class="keyword">if</span>(genericReturnType <span class="keyword">instanceof</span> ParameterizedType)&#123;</span><br><span class="line">                    <span class="keyword">return</span> doQuery(statementId, <span class="keyword">true</span>, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> doQuery(statementId, <span class="keyword">false</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (T) proxyInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的增删改查操作实际上还是通过JDBC来实现，所以声明一个<code>Executor</code>类来专门执行具体操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Configuration configuration, MappedStatement mappedStatement, Object... params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PreparedStatement preparedStatement = getPreparedStatement(configuration, mappedStatement, params);</span><br><span class="line">        <span class="comment">// 6 执行SQL，得到结果集</span></span><br><span class="line">        ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">        <span class="comment">// 7 对结果集进行转换</span></span><br><span class="line">        List&lt;Object&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 7.1 得到返回结果的类型</span></span><br><span class="line">        String resultType = mappedStatement.getResultType();</span><br><span class="line">        <span class="comment">// 7.2 转换为类</span></span><br><span class="line">        Class&lt;?&gt; resultTypeClass = getClassType(resultType);</span><br><span class="line">        <span class="comment">// 7.3 遍历结果集，逐个进行转换</span></span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            <span class="comment">// 声明返回类</span></span><br><span class="line">            Object o = resultTypeClass.newInstance();</span><br><span class="line">            <span class="comment">// 获取元数据</span></span><br><span class="line">            ResultSetMetaData metaData = resultSet.getMetaData();</span><br><span class="line">            <span class="comment">// 此处是从1开始</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= metaData.getColumnCount(); i++) &#123;</span><br><span class="line">                <span class="comment">// 字段名</span></span><br><span class="line">                String columnName = metaData.getColumnName(i);</span><br><span class="line">                <span class="comment">// 对应字段的值</span></span><br><span class="line">                Object value = resultSet.getObject(columnName);</span><br><span class="line">                <span class="comment">//使用内省，根据数据库表字段和实体属性的对应关系，完成封装</span></span><br><span class="line">                PropertyDescriptor propertyDescriptor = <span class="keyword">new</span> PropertyDescriptor(columnName, resultTypeClass);</span><br><span class="line">                <span class="comment">// 获取写方法，进行值写入</span></span><br><span class="line">                Method writeMethod = propertyDescriptor.getWriteMethod();</span><br><span class="line">                writeMethod.invoke(o,value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将本次转换的结果加入返回结果中</span></span><br><span class="line">            resultList.add(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (List&lt;E&gt;) resultList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateDatabase</span><span class="params">(Configuration configuration, MappedStatement mappedStatement, Object... params)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException, IllegalAccessException, NoSuchFieldException </span>&#123;</span><br><span class="line">        PreparedStatement preparedStatement = getPreparedStatement(configuration, mappedStatement, params[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">boolean</span> execute = preparedStatement.execute();</span><br><span class="line">        <span class="keyword">return</span> execute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> PreparedStatement <span class="title">getPreparedStatement</span><span class="params">(Configuration configuration, MappedStatement mappedStatement, Object... params)</span> <span class="keyword">throws</span> SQLException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">// 执行jdbc过程</span></span><br><span class="line">        <span class="comment">// 1 注册驱动获取连接，直接获取C3P0连接池里的连接</span></span><br><span class="line">        Connection connection = configuration.getDataSource().getConnection();</span><br><span class="line">        <span class="comment">// 2 获取要执行的SQL</span></span><br><span class="line">        String sql = mappedStatement.getSql();</span><br><span class="line">        <span class="comment">// 3 对SQL中存在的参数进行提取和转换</span></span><br><span class="line">        BoundSql boundSql = getBoundSql(sql);</span><br><span class="line">        <span class="comment">// 4 获取预处理对象</span></span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(boundSql.getSqlText());</span><br><span class="line">        <span class="comment">// 5 设置参数</span></span><br><span class="line">        <span class="comment">// 5.1 获取参数类型</span></span><br><span class="line">        String parameterType = mappedStatement.getParameterType();</span><br><span class="line">        <span class="comment">// 5.2 根据类型获取类</span></span><br><span class="line">        Class&lt;?&gt; parameterTypeClass = getClassType(parameterType);</span><br><span class="line">        <span class="comment">// 5.3 得到解析的参数列表</span></span><br><span class="line">        List&lt;ParameterMapping&gt; parameterMappingList = boundSql.getParameterMappingList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappingList.size(); i++) &#123;</span><br><span class="line">            ParameterMapping parameterMapping = parameterMappingList.get(i);</span><br><span class="line">            <span class="comment">// 得到参数值，即#&#123;id&#125;中的id</span></span><br><span class="line">            String content = parameterMapping.getContent();</span><br><span class="line">            Field declaredField = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 判断是否是基本数据类型或者其包装类</span></span><br><span class="line">            <span class="keyword">if</span> (isCommonDataType(parameterTypeClass) || isWrapClass(parameterTypeClass)) &#123;</span><br><span class="line">                declaredField = parameterTypeClass.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                declaredField = parameterTypeClass.getDeclaredField(content);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置权限暴力访问，防止属性私有不让访问</span></span><br><span class="line">            declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 得到对应的值</span></span><br><span class="line">            Object o = declaredField.get(params[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 将参数拼接到SQL上</span></span><br><span class="line">            preparedStatement.setObject(i + <span class="number">1</span>, o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preparedStatement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当前类型是否是基本数据类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Boolean <span class="title">isCommonDataType</span><span class="params">(Class clazz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clazz.isPrimitive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isWrapClass</span><span class="params">(Class clazz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Class) clazz.getField(<span class="string">&quot;TYPE&quot;</span>).get(<span class="keyword">null</span>)).isPrimitive();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据类型获取对应的class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; getClassType(String type) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span>(type != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(type);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对mapper中的原SQL进行解析和替换</span></span><br><span class="line"><span class="comment">     * 由于jdbc只认识?占位符，所以要把#&#123;id&#125;进行替换</span></span><br><span class="line"><span class="comment">     * 同时要得到其中的id，用于定位获取参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> BoundSql <span class="title">getBoundSql</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 标记处理类</span></span><br><span class="line">        ParameterMappingTokenHandler parameterMappingTokenHandler = <span class="keyword">new</span> ParameterMappingTokenHandler();</span><br><span class="line">        <span class="comment">// 第一个参数是开始标记、第二个是结束标记、第三个是使用那个处理类</span></span><br><span class="line">        GenericTokenParser genericTokenParser = <span class="keyword">new</span> GenericTokenParser(<span class="string">&quot;#&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, parameterMappingTokenHandler);</span><br><span class="line">        <span class="comment">// 得到处理后的SQL（参数已经变为?）</span></span><br><span class="line">        String formatSql = genericTokenParser.parse(sql);</span><br><span class="line">        <span class="comment">// 处理过程中，处理类已经将参数中的值进行了存储，直接获取即可</span></span><br><span class="line">        List&lt;ParameterMapping&gt; parameterMappings = parameterMappingTokenHandler.getParameterMappings();</span><br><span class="line">        <span class="comment">// 通过构造方法进行赋值</span></span><br><span class="line">        BoundSql boundSql = <span class="keyword">new</span> BoundSql(formatSql, parameterMappings);</span><br><span class="line">        <span class="keyword">return</span> boundSql;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一些基础的POJO这里就不再粘贴了，到此，框架的代码就基本开发完毕，下面进行测试。</p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h2><p>在客户端里声明测试类，进行如下的代码编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在测试方法执行前执行</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 将配置文件进行加载，得到字节流</span></span><br><span class="line">        InputStream resourceAsSteam = Resources.getResourceAsSteam(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 此次加载会将xml文件里面的内容加载到框架内</span></span><br><span class="line">        <span class="comment">// 通过字节流，得到sqlSession工厂</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(resourceAsSteam);</span><br><span class="line">        <span class="comment">// 通过工厂的openSession方法，生成一个session</span></span><br><span class="line">        sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不使用代理的模式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = sqlSession.selectList(<span class="string">&quot;com.ormtest.mapper.UserMapper.selectAll&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用代理模式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectAll();</span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终测试通过，查询结果正确。</p><p>至此，自定义Mybatis的简单实现就完成了~~</p>]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记-动态代理</title>
      <link href="/2020/01/23/java-dynamic-proxy/"/>
      <url>/2020/01/23/java-dynamic-proxy/</url>
      
        <content type="html"><![CDATA[<h2 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. 代理模式</h2><pre><code>代理模式一般指的是一个类代表另一个类的功能。这种类型的设计模式属于结构型模式，通过创建具有现有对象的对象，以便向外界提供功能接口。</code></pre><p>这里来举例说明：<br>歌星A，擅长唱歌；某晚会邀请A去唱歌，但是实际上不会直接联系A，而是联系A的经纪人B，经纪人经过合同谈判等步骤，最终A去晚会上进行了唱歌。<br>首先定义个接口Star里面定义了唱歌方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Star</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 唱歌</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 跳舞</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">dance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后声明实现类歌星A：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RapStar</span> <span class="keyword">implements</span> <span class="title">Star</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;RapStar开始freestyle！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;RapStar开始地板动作！&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们会定义一个经纪人类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Broker</span> <span class="keyword">implements</span> <span class="title">Star</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> RapStar rapStar;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Broker</span><span class="params">(RapStar rapStar)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.rapStar = rapStar;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;价钱谈好了，经纪人抽取提成......&quot;</span>);</span><br><span class="line">      rapStar.sing();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;价钱谈崩了，经纪人表示不跳舞&quot;</span>);</span><br><span class="line">      <span class="comment">// rapStar.dance();</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实际的调用就会是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Party</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     RapStar rapStar = <span class="keyword">new</span> RapStar();</span><br><span class="line">     System.out.println(<span class="string">&quot;今晚邀请了明星A&quot;</span>);</span><br><span class="line">      Star star = <span class="keyword">new</span> Broker(rapStar);</span><br><span class="line">      star.sing();</span><br><span class="line">      star.dance();  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出就会是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">今晚邀请了明星A</span><br><span class="line">价钱谈好了，经纪人抽取提成......</span><br><span class="line">RapStar开始freestyle！</span><br><span class="line">价钱谈崩了，经纪人表示不跳舞</span><br></pre></td></tr></table></figure><p>这样就达到了，在RapStar不变的情况下，进行方法的增强。</p><h2 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h2><p>静态代理就是在编译时就指定的代理，比如上述的例子中，指定了Broker代理RapStar，但是当现在来了一个演员明星ActorStar的时候，也需要Broker去代理，这时就不支持了，需要进行代码的修改。</p><h2 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h2><p>为了解决静态代理的问题，让程序动态的根据要进行代理的类自动生成代理类，这个就是动态代理。<br>常用的动态代理有两种：JDK动态代理、cglib动态代理。</p><h4 id="3-1-JDK动态代理"><a href="#3-1-JDK动态代理" class="headerlink" title="3.1 JDK动态代理"></a>3.1 JDK动态代理</h4><p>JDK动态代理的实现方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> method.invoke(obj, args);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过查看参数以及查看源码，可以知道：<br>使用JDK动态代理的类，必须实现某个接口（第二个参数需要传入实现的接口），最终底层会生成一个和当前需要代理的类实现了相同接口的类，实现了代理功能（类似上面的例子）。</p><h4 id="3-2-cglib动态代理"><a href="#3-2-cglib动态代理" class="headerlink" title="3.2 cglib动态代理"></a>3.2 cglib动态代理</h4><p>cglib动态代理的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Enhancer.create(obj.getClass(), <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(obj, objects);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>通过查看参数以及查看源码，可以知道：<br>使用cglib动态代理的类，不需要实现接口（可实现可不实现，不关注），它只有两个参数，最终底层是根据当前需要代理类，派生出一个子类，通过子类的方式实现了方法的代理增强。</p><p>两个动态代理都是通过里面的<code>invoke/intercept</code>方法，进行方法的代理增强。</p>]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习笔记-源码解读与插件原理</title>
      <link href="/2020/01/23/mybatis3/"/>
      <url>/2020/01/23/mybatis3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-mybatis架构简介"><a href="#1-mybatis架构简介" class="headerlink" title="1. mybatis架构简介"></a>1. mybatis架构简介</h2><blockquote><p>Mybatis的架构可以大致分为以下三层：<br>1、API接口层：对外提供增删改查接口，使用传统的MyBatis提供的API或者使用Mapper代理的方式；<br>2、数据处理层：完成参数映射、SQL解析与执行、结果处理等；<br>3、框架支撑层：支持基于XML或者注解定义SQL、事务管理、连接池管理、缓存管理等；</p></blockquote><p><strong>Mybatis作为一个ORM框架，实际上底层还是通过JDBC来操作数据库，完成增删改查的。</strong></p><p>想要详细了解底层的原理，首先需要知道Mybatis的九大核心的概念：<br>|组件  |作用  |<br>|–|–|<br>| SqlSession|作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成数据库增删改查功能|<br>|Executor|MyBatis执行器，是MyBatis调度的核心，负责SQL语句的生成和查询缓存的维护|<br>|StatementHandler|封装了JDBC Statement操作，负责对JDBC statement的操作，如设置参数、将Statement结果集转换成List集合|<br>|ParameterHandler|负责对用户传递的参数转换成JDBC Statement所需要的参数|<br>|ResultSetHandler|负责将JDBC返回的ResultSet结果集对象转换成List类型的集合|<br>|TypeHandler|负责java数据类型和jdbc数据类型之间的映射和转换|<br>|MappedStatement|MappedStatement维护了一条<code>＜select | update | delete | insert＞</code>节点的封装|<br>|SqlSource|负责根据用户传递的<code>parameterObject</code>，动态地生成SQL语句，将信息封装到<code>BoundSql</code>对象中，并返回|<br>|BoundSql |表示动态生成的SQL语句以及相应的参数信息|</p><p>Mybatis完成一次查询或者其他操作的大致流程如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201023154330286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xmajM5NzQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>简单描述Mybatis执行过程如下：</p><ol><li>加载核心配置文件，得到数据库连接信息，创建核心配置对象保存生成的连接池等信息；</li><li>加载映射配置文件，将<code>namespace</code>和SQL语句标签的<code>id</code>，组合作为id，最终封装成为一个<code>MappedStatement</code>对象，存放到内存中；</li><li>调用<code>OpenSession</code>方法获得会话，然后调用相应的增删改查方法，方法参数为<code>namespace+id</code>；</li><li>接收到处理请求，由<code>Executor</code>的默认实现类<code>BaseExecutor</code>来处理，首先封装<code>BoundSql</code>对象，并根据分页等信息生成缓存的Key；</li><li>判断缓存中是否有，如果有则返回，如果没有进行数据库的查询；</li><li>进入<code>SimpleExecutor</code>中进行数据库的查询，调用<code>StatementHandler</code>来处理，而它先通过<code>ParameterHandler</code>进行参数设置，通过<code>TypeHandler</code>将java类型转换成为数据库类型；</li><li>最终调用JDBC的操作，完成查询，得到<code>ResultSet</code>；</li><li>然后通过<code>ResultSetHandler</code>处理器将结果进行处理，最终返回指定的结果类型；</li></ol><h2 id="2-mybatis源码分析"><a href="#2-mybatis源码分析" class="headerlink" title="2. mybatis源码分析"></a>2. mybatis源码分析</h2><p>首先，通过传统模式调用mybatis的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">//1.加载核心配置文件为字节流</span></span><br><span class="line">       InputStream resourceAsStream = Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">       <span class="comment">//2.解析配置文件，并创建了sqlSessionFactory</span></span><br><span class="line">       SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(resourceAsStream);</span><br><span class="line">       <span class="comment">//3.开启一个sqlSession会话，此处可以传参boolean类型，参数表示事务是否自动提交，目前是需要手动提交</span></span><br><span class="line">       SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">       <span class="comment">//4.sqlSession调用方法，传入namespace+id</span></span><br><span class="line">       List&lt;User&gt; users = sqlSession.selectList(<span class="string">&quot;user.findAll&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">           System.out.println(user);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 最终关闭会话</span></span><br><span class="line">       sqlSession.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这种传统方式的缺点也很明显，<code>namespace+id是硬编码</code>，如果很多地方使用时，发生变化，则需要修改所有的地方。<br>针对这个问题，Mybatis还支持动态代理的方式，就是通过<code>getMapper</code>的方式，无需指定:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       InputStream resourceAsStream = Resources.getResourceAsStream(<span class="string">&quot;sqlMapConfig.xml&quot;</span>);</span><br><span class="line">       SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(resourceAsStream);</span><br><span class="line">       SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">       UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">       List&lt;User&gt; userList= mapper.findAllUser();</span><br><span class="line">       <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">           System.out.println(user);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这种代理方式是如何实现的呢？<br>下面跟随源码进行查看，通过一步一步的进入，发现从<code>SqlSession</code>的实现类<code>DefaultSqlSession</code>一直到<code>MapperProxyFactory</code>最终找到具体的实现方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[]&#123;mapperInterface&#125;, mapperProxy);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//MapperProxyFactory类中的newInstance方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 创建了JDK动态代理的invocationHandler接口的实现类mapperProxy</span></span><br><span class="line">       <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">       <span class="comment">// 调用了重载方法</span></span><br><span class="line">       <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>到此处我们可以确定Mybatis是通过<code>JDK动态代理</code>的方式进行代理对象的产生。</p><p><strong>同时，这里也可以解释为什么Mybatis规定Mapper的namespace要和mapper的全限定名一致，为什么SQL语句的id要与方法名一致。<br>因为，动态代理中只能获取到要执行哪个类下的哪个方法，无法获取xml里面的信息，所以让两者保持一致，可以直接定位到具体要执行的是哪个SQL。</strong></p><p>通过JDK动态代理的参数可知，最终是由<code>MapperProxy</code>来进行的代理增强，进入其中查看<code>invoke</code>发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">               <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">               <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">       <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>所以最终通过<code>method</code>参数获取到要执行的是哪个SQL，最终交给<code>mapperMethod</code>完成执行，进行上面讲的步骤，最终得到结果。</p><h2 id="3-插件原理与自定义"><a href="#3-插件原理与自定义" class="headerlink" title="3. 插件原理与自定义"></a>3. 插件原理与自定义</h2><p>插件对mybatis来说就是拦截器，用来增强核心对象的功能，增强功能本质上是借助于底层的动态代理实现的。</p><p>Mybatis对持久层的操作就是借助于四大核心对象，<code>Executor、StatementHandler、ParameterHandler、ResultSetHandler</code>，在上面分析源码时，会发现这四大核心对象都有拦截判断，我们就是通过拦截这四大对象来进行插件的开发。</p><p>进入<code>org.apache.ibatis.session.Configuration</code>核心配置类中，可以看到针对<code>Executor</code>的拦截器判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获得执行器类型</span></span><br><span class="line">       executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType; <span class="comment">// 使用默认</span></span><br><span class="line">       executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType; <span class="comment">// 使用 ExecutorType.SIMPLE</span></span><br><span class="line">       <span class="comment">// 创建对应实现的 Executor 对象</span></span><br><span class="line">       Executor executor;</span><br><span class="line">       <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">           executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">           executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果开启缓存，创建 CachingExecutor 对象，进行包装</span></span><br><span class="line">       <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">           executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 此处是加载所有的针对Executor的插件</span></span><br><span class="line">       executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">       <span class="keyword">return</span> executor;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>针对<code>ParameterHandler</code>的插件加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 创建 ParameterHandler 对象</span></span><br><span class="line">       ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">       <span class="comment">// 此处是加载所有的针对ParameterHandler的插件</span></span><br><span class="line">       parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">       <span class="keyword">return</span> parameterHandler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>针对<code>StatementHandler </code>插件加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 创建 RoutingStatementHandler 对象</span></span><br><span class="line">       StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">       <span class="comment">// 此处是加载所有的针对StatementHandler的插件</span></span><br><span class="line">       statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">       <span class="keyword">return</span> statementHandler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>针对<code>ResultSetHandler</code>插件加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 创建 DefaultResultSetHandler 对象</span></span><br><span class="line">       ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">       <span class="comment">// 此处是加载所有的针对ResultSetHandler的插件</span></span><br><span class="line">       resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">       <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过上面的源码我们会发现，在这四大对象创建的时候会进行插件的加载，而且加载的方法是相同的，都是<code>interceptorChain.pluginAll()</code>，所以我们进入该方法，查看具体的加载逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">           target = interceptor.plugin(target);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> target;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在深入进入会发现如下逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获得拦截的方法映射</span></span><br><span class="line">       Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">       <span class="comment">// 获得目标类的类型</span></span><br><span class="line">       Class&lt;?&gt; type = target.getClass();</span><br><span class="line">       <span class="comment">// 获得目标类的接口集合</span></span><br><span class="line">       Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">       <span class="comment">// 若有接口，则创建目标对象的 JDK Proxy 对象</span></span><br><span class="line">       <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                   type.getClassLoader(),</span><br><span class="line">                   interfaces,</span><br><span class="line">                   <span class="keyword">new</span> Plugin(target, interceptor, signatureMap)); <span class="comment">// 因为 Plugin 实现了 InvocationHandler 接口，所以可以作为 JDK 动态代理的调用处理器</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果没有，则返回原始的目标对象</span></span><br><span class="line">       <span class="keyword">return</span> target;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过上面的源码，我们发现最终拦截器或者插件的实现原理就是通过<code>JDK动态代理</code>来实现的。</p><p><code>interceptorChain</code>保存了所有的拦截器(interceptors)，在Mybatis初始化的时候创建。<br>当创建四大对象时，调用拦截器链中的拦截器依次的对目标进行拦截或增强。<br><code>interceptor.plugin(target)</code>中的<code>target</code>就可以理解为要被拦截的四大对象。返回的<code>target</code>就是被重重代理后的对象。</p><p>这时候如果我们想要自定义一个插件，只需要实现Mybatis的<code>Interceptor</code>接口，重写其中的方法就行了，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta">        @Signature(type= StatementHandler.class,</span></span><br><span class="line"><span class="meta">                  method = &quot;prepare&quot;,</span></span><br><span class="line"><span class="meta">                  args = &#123;Connection.class,Integer.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只要被拦截的目标对象的目标方法被执行时，每次都会执行intercept方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对方法进行了增强....&quot;</span>);</span><br><span class="line">        <span class="comment">// 增强逻辑执行完毕后，原方法执行</span></span><br><span class="line">        <span class="keyword">return</span> invocation.proceed(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要为了把当前的拦截器生成代理存到拦截器链中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        Object wrap = Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> wrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取配置文件的参数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取到的配置文件的参数是：&quot;</span>+properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>@Intercepts</code>和<code>@Signature</code>注解，可以指定自定义的拦截器(插件)是在哪个类的哪个方法执行时进行拦截，可以定义多个<code>@Signature</code>，同时对多个方法进行拦截。</p><p>当然，插件开发完毕后，也不是直接就会生效，还需要将其配置到Mybatis的核心配置文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.jfl.test.plugin.MyPlugin&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置之后，在Mybatis启动时就会将这个插件放入<code>interceptorChain</code>中，最终生成代理对象完成增强的方法的执行。</p>]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习笔记-注解、延迟加载以及缓存</title>
      <link href="/2020/01/23/mybatis2/"/>
      <url>/2020/01/23/mybatis2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-mybatis注解"><a href="#1-mybatis注解" class="headerlink" title="1. mybatis注解"></a>1. mybatis注解</h2><blockquote><p>上一章介绍mybatis的使用时，主要介绍的是通过XML方式进行SQL相关配置，其实我们还可以通过注解来减少编写Mapper映射文件，本章就主要讲解相关的注解。</p></blockquote><h4 id="1-1-常用的CRUD注解"><a href="#1-1-常用的CRUD注解" class="headerlink" title="1.1 常用的CRUD注解"></a>1.1 常用的CRUD注解</h4><ul><li>@Insert：实现新增</li><li>@Update：实现更新</li><li>@Delete：实现删除</li><li>@Select：实现查询</li></ul><p>通过上面的注解，可以替代mapper.xml里面的相关SQL标签，例如通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>可以替代</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-2-结果集注解"><a href="#1-2-结果集注解" class="headerlink" title="1.2 结果集注解"></a>1.2 结果集注解</h4><p>在注解模式中，怎么指定返回的结果集中数据库字段与实体属性名的对应关系呢？<br>主要是通过<code>@Result和@Results</code>来实现，具体示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">   <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">           @Result(property = &quot;id&quot;,column = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">           @Result(property = &quot;name&quot;,column = &quot;name&quot;)</span></span><br><span class="line"><span class="meta">   &#125;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>其中的属性的解释：</p><ul><li>property：对应xml中resultMap的property属性，代表类属性名；</li><li>column：对象xml中resultMap的column属性，代表表字段名；</li><li>javaType：对应的java数据类型</li></ul><h4 id="1-3-复杂映射注解"><a href="#1-3-复杂映射注解" class="headerlink" title="1.3 复杂映射注解"></a>1.3 复杂映射注解</h4><p>复杂映射主要是分为一对一、一对多、多对多，通过上一章我们知道多对多就是两个一对多，所以此处只演示一对一和一对多两种情况。</p><h6 id="1-3-1-一对一"><a href="#1-3-1-一对一" class="headerlink" title="1.3.1 一对一"></a>1.3.1 一对一</h6><p>一对一的注解是<code>@One</code>,它代替了<code>&lt;association/&gt;</code>标签，来指定子查询返回的对象信息。其中的属性讲解：</p><ul><li>select：指定关联的查询方法的全限定方法名</li></ul><p>同时，<code>column</code>属性对应的<code>pid</code>值就是要传入子查询的参数。</p><p>通过上一章的用户和省信息的一对一例子来演示，通过注解实现时，等于是将查询拆分成两个，首先是查询用户、其次是查询省份信息。<br>所以我们需要在<code>ProvinceMapp.java</code>里定义查询<code>findById()</code>，提供给用户查询时调用，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">           @Result(property = &quot;id&quot;,column = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">           @Result(property = &quot;name&quot;,column = &quot;name&quot;),</span></span><br><span class="line"><span class="meta">           @Result(property = &quot;province&quot;,column = &quot;pid&quot;,javaType = Province.class,</span></span><br><span class="line"><span class="meta">                   one=@One(select = &quot;com.jfl.test.mapper.ProvinceMapper.findById&quot;))</span></span><br><span class="line"><span class="meta">   &#125;)</span></span><br><span class="line">   <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserAndProvince</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>同时，在<code>ProvinceMapper.java</code>中提供如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&#123;&quot;select * from province where pid = #&#123;pid&#125;&quot;&#125;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Province <span class="title">findById</span><span class="params">(Integer pid)</span></span>;</span><br></pre></td></tr></table></figure><p>当进行用户查询时，同时将用户信息中的<code>pid</code>传入指定的省信息查询方法，最终返回用户和省信息的综合信息，完成一对一的查询。</p><h6 id="1-3-2-一对多"><a href="#1-3-2-一对多" class="headerlink" title="1.3.2 一对多"></a>1.3.2 一对多</h6><p>一对多的注解是<code>@Many</code>,它代替了<code>&lt;collection/&gt;</code>标签，来指定子查询返回的对象信息。其中的属性讲解：</p><ul><li>select：指定关联的查询方法的全限定方法名</li></ul><p>具体使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from province&quot;)</span></span><br><span class="line">   <span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">           @Result(property = &quot;pid&quot;,column = &quot;pid&quot;),</span></span><br><span class="line"><span class="meta">           @Result(property = &quot;pname&quot;,column = &quot;pname&quot;),</span></span><br><span class="line"><span class="meta">           @Result(property = &quot;userList&quot;,column = &quot;pid&quot;,javaType = List.class,</span></span><br><span class="line"><span class="meta">               many=@Many(select = &quot;com.jfl.test.mapper.UserMapper.findUserByPid&quot;))</span></span><br><span class="line"><span class="meta">   &#125;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Province&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>同时，用户那变需要提供对应的查询方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user where pid = #&#123;pid&#125;&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Order&gt; <span class="title">findUserByPid</span><span class="params">(Integer pid)</span></span>;</span><br></pre></td></tr></table></figure><p>最终就会返回一对多的结果。<br>在使用上，一对多和一对一基本一样，只有注解以及返回结果类型的差异。</p><h2 id="2-延迟加载"><a href="#2-延迟加载" class="headerlink" title="2. 延迟加载"></a>2. 延迟加载</h2><blockquote><p>延迟加载就是在需要⽤到数据时才进⾏加载，不需要⽤到数据时就不加载数据。<br>延迟加载也称懒加载。<br>延迟加载是基于嵌套查询来实现的。<br>Mybatis是支持延迟加载的，只不过默认是关闭状态。</p></blockquote><p>在开发过程中，很多时候我们并不需要在加载省份信息时就⼀定要加载关联的用户信息。此时就是我们所说的延迟加载。<br>延迟加载分为局部延迟加载和全局延迟加载，主要是根据配置的位置不同，影响的范围不同。<br>延迟加载是基于嵌套查询来实现的，因为它是将关联的查询进行延迟查询来实现延迟加载，如果使用的是<code>left join</code>或者其他非嵌套的查询，是没法进行延迟加载。</p><h4 id="2-1-局部延迟加载"><a href="#2-1-局部延迟加载" class="headerlink" title="2.1 局部延迟加载"></a>2.1 局部延迟加载</h4><p>在<code>&lt;association/&gt;</code>和<code>&lt;collection/&gt;</code>标签中都有⼀个<code>fetchType</code>属性，通过修改它的值<code>lazy </code>还是<code>eager</code>，可以修改局部的加载策略。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.jfl.test.User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> fetchType=&quot;lazy&quot; : 懒加载策略</span></span><br><span class="line"><span class="comment"> fetchType=&quot;eager&quot; : ⽴即加载策略</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;province&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;province&quot;</span> <span class="attr">column</span>=<span class="string">&quot;pid&quot;</span> <span class="attr">select</span>=<span class="string">&quot;com.jfl.test.mapper.ProvinceMapper.findById&quot;</span> <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;pid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;pname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种情况下，只有这一个查询会进行延迟加载。</p><h4 id="2-2-全局延迟加载"><a href="#2-2-全局延迟加载" class="headerlink" title="2.2 全局延迟加载"></a>2.2 全局延迟加载</h4><p>想要全局的嵌套查询都进行延迟加载的话，在Mybatis的核⼼配置⽂件中可以使⽤<code>setting</code>标签修改全局的加载策略。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启全局延迟加载功能--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：加载策略的优先级是局部高于全局，也就类似于就近原则，如果sql上配置了立即加载，就算配了全局延迟的策略，但是在这个sql执行时也不会延迟加载。</strong></p><h4 id="2-3-延迟加载触发"><a href="#2-3-延迟加载触发" class="headerlink" title="2.3 延迟加载触发"></a>2.3 延迟加载触发</h4><p>当配置了延迟加载策略后，会发现即使没有调⽤关联对象的任何⽅法，但是在调⽤当前对象的equals、clone、hashCode、toString⽅法时也会触发关联对象的查询。<br>查看源码，可以看到在<code>org.apache.ibatis.session.Configuration</code>里默认触发中有这几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line">.......</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定对象的哪个方法会触发延迟加载。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Set&lt;String&gt; lazyLoadTriggerMethods = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">&quot;equals&quot;</span>, <span class="string">&quot;clone&quot;</span>, <span class="string">&quot;hashCode&quot;</span>, <span class="string">&quot;toString&quot;</span>));</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决这个问题，可以通过配置覆盖掉上诉的方法，具体配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启全局延迟加载功能--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--所有⽅法都会延迟加载--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-4-延迟加载原理"><a href="#2-4-延迟加载原理" class="headerlink" title="2.4 延迟加载原理"></a>2.4 延迟加载原理</h4><blockquote><p>其实底层是通过动态代理(默认使⽤Javassist代理⼯⼚)来实现的延迟加载</p></blockquote><p>当查询用户时，发现如果有懒加载的配置,如：<code>fetchType=&quot;lazy&quot;</code>，则将User生成一个代理对象进行返回，并把懒加载相关对象放到<code>ResultLoaderMap</code>中存起来，当调用到懒加载相关方法时，根据代理类的<code>invoke</code>进行具体的SQL查询，最终得到结果。<br>通过<code>org.apache.ibatis.session.Configuration</code>里的<code>setProxyFactory</code>方法可以看到默认情况下使用的是<code>JavassistProxyFactory</code>，部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 默认使⽤Javassist代理⼯⼚</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> proxyFactory</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProxyFactory</span><span class="params">(ProxyFactory proxyFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (proxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">proxyFactory = <span class="keyword">new</span> JavassistProxyFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.proxyFactory = proxyFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过追踪代码，可以看到Mybatis的查询结果是由<code>ResultSetHandler</code>接⼝的<code>handleResultSets()</code>⽅法处理的，所以可以进入它唯一的实现类<code>DefaultResultSetHandler</code>来查看具体逻辑，主要方法是<code>createResultObject</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建映射后的结果对象</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Object <span class="title">createResultObject</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultLoaderMap lazyLoader, String columnPrefix)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">       <span class="comment">// useConstructorMappings ，表示是否使用构造方法创建该结果对象。此处将其重置</span></span><br><span class="line">       <span class="keyword">this</span>.useConstructorMappings = <span class="keyword">false</span>; <span class="comment">// reset previous mapping result</span></span><br><span class="line">       <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; constructorArgTypes = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 记录使用的构造方法的参数类型的数组</span></span><br><span class="line">       <span class="keyword">final</span> List&lt;Object&gt; constructorArgs = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 记录使用的构造方法的参数值的数组</span></span><br><span class="line">       <span class="comment">// 创建映射后的结果对象</span></span><br><span class="line">       Object resultObject = createResultObject(rsw, resultMap, constructorArgTypes, constructorArgs, columnPrefix);</span><br><span class="line">       <span class="keyword">if</span> (resultObject != <span class="keyword">null</span> &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) &#123;</span><br><span class="line">           <span class="comment">// 如果有内嵌的查询，并且开启延迟加载，则创建结果对象的代理对象</span></span><br><span class="line">           <span class="keyword">final</span> List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings();</span><br><span class="line">           <span class="keyword">for</span> (ResultMapping propertyMapping : propertyMappings) &#123;</span><br><span class="line">               <span class="comment">// issue gcode #109 &amp;&amp; issue #149</span></span><br><span class="line">               <span class="keyword">if</span> (propertyMapping.getNestedQueryId() != <span class="keyword">null</span> &amp;&amp; propertyMapping.isLazy()) &#123;</span><br><span class="line">                   resultObject = configuration.getProxyFactory().createProxy(resultObject, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 判断是否使用构造方法创建该结果对象</span></span><br><span class="line">       <span class="keyword">this</span>.useConstructorMappings = resultObject != <span class="keyword">null</span> &amp;&amp; !constructorArgTypes.isEmpty(); <span class="comment">// set current mapping result</span></span><br><span class="line">       <span class="keyword">return</span> resultObject;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过源码会看到在发现有延迟加载的属性时，会去调用<code>configuration.getProxyFactory().createProxy()</code>产生一个代理对象并返回，<code>configuration.getProxyFactory()</code>返回的就是上面说的默认代理对象工厂<code>JavassistProxyFactory</code>，然后调用工厂的<code>createProxy()</code>方法，查看源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">(Object target, ResultLoaderMap lazyLoader, Configuration configuration, ObjectFactory objectFactory, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> EnhancedResultObjectProxyImpl.createProxy(target, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>看到最终返回的是<code>EnhancedResultObjectProxyImpl</code>的相关返回的结果，看到这个名字可以得到使用的应该就是<code>cglib</code>的动态代理。进入该类中，可以看到具体的<code>cglib</code>的创建逻辑以及调用时会执行的<code>invoke</code>方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">crateProxy</span><span class="params">(Class&lt;?&gt; type, MethodHandler callback, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 javassist ProxyFactory 对象</span></span><br><span class="line">        ProxyFactory enhancer = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        <span class="comment">// 设置父类</span></span><br><span class="line">        enhancer.setSuperclass(type);</span><br><span class="line">        <span class="comment">// 根据情况，设置接口为 WriteReplaceInterface 。和序列化相关，可以无视</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            type.getDeclaredMethod(WRITE_REPLACE_METHOD); <span class="comment">// 如果已经存在 writeReplace 方法，则不用设置接口为 WriteReplaceInterface</span></span><br><span class="line">            <span class="comment">// ObjectOutputStream will call writeReplace of objects returned by writeReplace</span></span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(WRITE_REPLACE_METHOD + <span class="string">&quot; method was found on bean &quot;</span> + type + <span class="string">&quot;, make sure it returns this&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            enhancer.setInterfaces(<span class="keyword">new</span> Class[]&#123;WriteReplaceInterface.class&#125;); <span class="comment">// 如果不存在 writeReplace 方法，则设置接口为 WriteReplaceInterface</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            <span class="comment">// nothing to do here</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        Object enhanced;</span><br><span class="line">        Class&lt;?&gt;[] typesArray = constructorArgTypes.toArray(<span class="keyword">new</span> Class[constructorArgTypes.size()]);</span><br><span class="line">        Object[] valuesArray = constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            enhanced = enhancer.create(typesArray, valuesArray);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Error creating lazy proxy.  Cause: &quot;</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置代理对象的执行器</span></span><br><span class="line">        ((Proxy) enhanced).setHandler(callback);</span><br><span class="line">        <span class="keyword">return</span> enhanced;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到最终使用的是<code>enhancer.create</code>，所以可以确定是<code>cglib</code>动态代理来产生代理对象。<br>再查看下<code>invoke</code>方法，看具体是怎么执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FINALIZE_METHOD = <span class="string">&quot;finalize&quot;</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WRITE_REPLACE_METHOD = <span class="string">&quot;writeReplace&quot;</span>;</span><br><span class="line">   </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object enhanced, Method method, Method methodProxy, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   <span class="comment">// 得到执行的方法名</span></span><br><span class="line">       <span class="keyword">final</span> String methodName = method.getName();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (lazyLoader) &#123;</span><br><span class="line">           <span class="comment">// 不匹配，直接进入else</span></span><br><span class="line">               <span class="keyword">if</span> (WRITE_REPLACE_METHOD.equals(methodName)) &#123;</span><br><span class="line">                   Object original;</span><br><span class="line">                   <span class="comment">// 判断构造函数是否无参</span></span><br><span class="line">                   <span class="keyword">if</span> (constructorArgTypes.isEmpty()) &#123;</span><br><span class="line">                       original = objectFactory.create(type);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       original = objectFactory.create(type, constructorArgTypes, constructorArgs);</span><br><span class="line">                   &#125;</span><br><span class="line">                   PropertyCopier.copyBeanProperties(type, enhanced, original);</span><br><span class="line">                   <span class="keyword">if</span> (lazyLoader.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">new</span> JavassistSerialStateHolder(original, lazyLoader.getProperties(), objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="keyword">return</span> original;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 是否有延迟加载</span></span><br><span class="line">                   <span class="keyword">if</span> (lazyLoader.size() &gt; <span class="number">0</span> &amp;&amp; !FINALIZE_METHOD.equals(methodName)) &#123;</span><br><span class="line">                       <span class="comment">// 加载所有延迟加载的属性</span></span><br><span class="line">                       <span class="keyword">if</span> (aggressive || lazyLoadTriggerMethods.contains(methodName)) &#123;</span><br><span class="line">                           lazyLoader.loadAll();</span><br><span class="line">                       <span class="comment">// 如果调用了 setting 方法，则不在使用延迟加载</span></span><br><span class="line">                       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PropertyNamer.isSetter(methodName)) &#123;</span><br><span class="line">                           <span class="keyword">final</span> String property = PropertyNamer.methodToProperty(methodName);</span><br><span class="line">                           lazyLoader.remove(property); <span class="comment">// 移除</span></span><br><span class="line">                       <span class="comment">// 如果调用了 getting 方法，则执行延迟加载</span></span><br><span class="line">                       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PropertyNamer.isGetter(methodName)) &#123;</span><br><span class="line">                           <span class="keyword">final</span> String property = PropertyNamer.methodToProperty(methodName);</span><br><span class="line">                           <span class="keyword">if</span> (lazyLoader.hasLoader(property)) &#123;</span><br><span class="line">                           <span class="comment">// 延迟加载单个属性</span></span><br><span class="line">                               lazyLoader.load(property);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 继续执行原方法</span></span><br><span class="line">           <span class="keyword">return</span> methodProxy.invoke(enhanced, args);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">           <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过以上源码分析，可以印证最开始所讲的，通过动态代理来实现的延迟加载。</p><h2 id="3-缓存机制"><a href="#3-缓存机制" class="headerlink" title="3. 缓存机制"></a>3. 缓存机制</h2><blockquote><p>mybatis的缓存分为一级缓存和二级缓存；<br>一级缓存默认开启，二级缓存默认关闭<br>二级缓存会引起脏读，所以不建议使用，常用redis做数据缓存</p></blockquote><h4 id="3-1-一级缓存"><a href="#3-1-一级缓存" class="headerlink" title="3.1 一级缓存"></a>3.1 一级缓存</h4><p>一级缓存的有效范围是同一个sqlSession；同一个sqlSession中执行相同的查询，第二次查询不会访问数据库，直接从一级缓存获取，返回给调用者。<br>但是如果两次查询中间有增删改操作，则会刷新一级缓存，这时第二次查询依然会去查询数据库。<br>通过分析源码，可以知道<code>一级缓存的数据结构就是一个HashMap</code>：<br><img src="https://img-blog.csdnimg.cn/20201022165105302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xmajM5NzQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>，而这个map的key就是mapperstatement（保存了要执行的SQL的信息）、参数、分页信息、最终执行的SQL来组成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为本次查询创建缓存的Key</span></span><br><span class="line">   CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br></pre></td></tr></table></figure><p>所以每一个SqISession都会存放一个map对象的引用，那什么时候会创建一级缓存的Map呢，通过源码分析得知是通过<code>BaseExecutor</code>来创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">BaseExecutor</span><span class="params">(Configuration configuration, Transaction transaction)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.transaction = transaction;</span><br><span class="line">       <span class="keyword">this</span>.deferredLoads = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">       <span class="comment">// 创建本地缓存</span></span><br><span class="line">       <span class="keyword">this</span>.localCache = <span class="keyword">new</span> PerpetualCache(<span class="string">&quot;LocalCache&quot;</span>);</span><br><span class="line">       <span class="keyword">this</span>.localOutputParameterCache = <span class="keyword">new</span> PerpetualCache(<span class="string">&quot;LocalOutputParameterCache&quot;</span>);</span><br><span class="line">       <span class="keyword">this</span>.closed = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">       <span class="keyword">this</span>.wrapper = <span class="keyword">this</span>; <span class="comment">// 自己</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>当执行查询的时候，就会先去缓存中取，如果取不到再走查询，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">       ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">       <span class="comment">// 已经关闭，则抛出 ExecutorException 异常</span></span><br><span class="line">       <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 清空本地缓存，如果 queryStack 为零，并且要求清空本地缓存。</span></span><br><span class="line">       <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">           clearLocalCache();</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;E&gt; list;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// queryStack + 1</span></span><br><span class="line">           queryStack++;</span><br><span class="line">           <span class="comment">// 从一级缓存中，获取查询结果</span></span><br><span class="line">           list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// 获取到，则进行处理</span></span><br><span class="line">           <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">               handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">           <span class="comment">// 获得不到，则从数据库中查询</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// queryStack - 1</span></span><br><span class="line">           queryStack--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 执行延迟加载</span></span><br><span class="line">           <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">               deferredLoad.load();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// issue #601</span></span><br><span class="line">           <span class="comment">// 清空 deferredLoads</span></span><br><span class="line">           deferredLoads.clear();</span><br><span class="line">           <span class="comment">// 如果缓存级别是 LocalCacheScope.STATEMENT ，则进行清理</span></span><br><span class="line">           <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">               <span class="comment">// issue #482</span></span><br><span class="line">               clearLocalCache();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>缓存中如果查不到的话，就从数据库查，在<code>queryFromDatabase</code>方法中，会将查询结果写入localcache，内部调用的是Map的put方法，最终交给Map进行存放。</p><h4 id="3-2-二级缓存"><a href="#3-2-二级缓存" class="headerlink" title="3.2 二级缓存"></a>3.2 二级缓存</h4><p>二级缓存的原理和数据结构，和一级缓存是一样的，不过二级缓存的作用范围是基于mapper文件的namespace的，也就是说多个sqlSession可以共享一个mapper中的二级缓存区域，并且如果多个mapper的namespace相同，即使是两个mapper，那么这两个mapper中执行sql查询到的数据也将存在相同的二级缓存区域中。<br>由于二级缓存默认是关闭，如果打开需要进行配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其次在Mapper.xml文件中开启缓存：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure><p>空标签说明使用mybatis自身的二级缓存，也可以进行指定：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.redis.RedisCache&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这个就是指定使用redis作为二级缓存。<br>使用二级缓存需要pojo实现Serializable接口，为了将缓存数据取出执行反序列化操作，因为二级缓存数据存储介质多种多样，不一定只存在内存中，有可能存在硬盘中，如果我们要再取这个缓存的话，就需要反序列化了。</p><p>上面描述的是全局的配置，如果单独开启，则在sql标签上使用<code>userCache</code>和<code>flushCache</code>等配置项，useCache为true则使用二级缓存，否则不使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByUserId&quot;</span> <span class="attr">useCache</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">resultType</span>=<span class="string">&quot;com.jfl.test.pojo.User&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">select * from user where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置<code>flushCache=&quot;true”</code>则会在增删改之后刷新缓存，默认是true，如果不刷新，则会出现脏读等问题。</p><h4 id="3-3-redis做为二级缓存"><a href="#3-3-redis做为二级缓存" class="headerlink" title="3.3 redis做为二级缓存"></a>3.3 redis做为二级缓存</h4><p>使用mybatis自带的二级缓存存在以下问题：</p><ul><li>自带的二级缓存是单服务器工作，无法实现分布式缓存；</li><li>当进行嵌套查询时，A表关联的B表数据，通过A查询时，最终结果是存在A的二级缓存中，当B发生改变，A的二级缓存是不会进行刷新的，会导致脏读等问题；</li></ul><p>所以尽可能的不使用自带的二级缓存，而redis就是一个很好的分布式缓存，所以一般都是使用redis来做缓存。<br>主要的原理是redis提供的缓存，实现了mybatis的Cache接口，在配置时可以指定具体实现类，来使用redis的缓存。<br>mybatis-redis在存储数据的时候，是使用的hash结构，把cache的id作为这个hash的key (cache的id在mybatis中就是mapper的namespace)；这个mapper中的查询缓存数据作为 hash的field，需要缓存的内容直接使用SerializeUtil存储，SerializeUtil和其他的序列化类差不多，负责对象的序列化和反序列化；</p>]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis学习笔记-基本概念和复杂映射</title>
      <link href="/2020/01/22/mybatis1/"/>
      <url>/2020/01/22/mybatis1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><blockquote><p>MyBatis是一款优秀的基于ORM的半自动轻量级持久层框架，它支持定制化SQL、存储过程以及高级映射，使用XML或注解实现映射对应，结果集自动转换成指定类型，无需自己处理。</p></blockquote><h4 id="1-1-什么是ORM"><a href="#1-1-什么是ORM" class="headerlink" title="1.1 什么是ORM"></a>1.1 什么是ORM</h4><p>ORM全称Object/Relation Mapping：表示对象-关系映射的缩写，它完成面向对象的编程语言到关系数据库的映射。<br>采用ORM框架后，应用程序不再直接访问底层数据库，而是以面向对象的方式来操作持久化对象，而ORM框架则将这些面向对象的操作转换成底层SQL操作。<br>ORM框架实现的效果：把对持久化对象的保存、修改、删除等操作，转换为对数据库的insert、update、delete操作。</p><h4 id="1-2-什么是半自动"><a href="#1-2-什么是半自动" class="headerlink" title="1.2 什么是半自动"></a>1.2 什么是半自动</h4><p>简单来说，半自动就是还需要开发人员自己写核心的SQL。<br>与之对应的就是全自动，类似Hibernate等，就是无需写SQL都是全自动完成。</p><h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2. 配置文件"></a>2. 配置文件</h3><blockquote><p>Mybatis的配置文件一般分为两种，一个是核心配置文件，一个是映射配置文件，<br>核心配置文件配置了Mybatis的核心配置，包括数据库连接信息、是否开启缓存等；<br>映射配置文件主要是用于配置具体的映射关系的文件；</p></blockquote><h4 id="2-1-核心配置文件"><a href="#2-1-核心配置文件" class="headerlink" title="2.1 核心配置文件"></a>2.1 核心配置文件</h4><p>Mybatis的核心配置文件一般我们命名为sqlMapConfig.xml，里面配置了相关的标签，来指定一些操作（标签是存在顺序的，如果顺序写错，会有提示），具体概述如下：</p><ul><li><code>&lt;configration/&gt;</code>：顶层配置标签</li><li><code>&lt;properties/&gt;</code>：加载额外配置的properties文件</li><li><code>&lt;setting/&gt;</code>:全局配置，例如是否使用缓存、超时时间设置等</li><li><code>&lt;typeAliases/&gt;</code>：类型别名，给parameterType或者ResultType定义别名</li><li><code>&lt;typeHandlers/&gt;</code>：类型处理器，配置将sql返回的数据库类型转换为相应Java类型的处理器</li><li><code>&lt;objectFactory/&gt;</code>：对象工厂，可以继承DefaultObjectFactory来定义对象工厂</li><li><code>&lt;plugins/&gt;</code>：插件，其实就是拦截器，通过实现Interceptor接口，并添加Intercepts注解（里面可以定义多个signature去拦截多个方法）</li><li><code>&lt;environments/&gt;</code>：环境，里面可以定义多个环境变量（环境变量中可以指定事务、数据源等信息），由default来指定默认使用那个</li><li><code>&lt;databaseIdProvider/&gt;</code>：数据库厂商标识</li><li><code>&lt;mappers/&gt;</code>：需要加载的映射配置文件（可以通过package或者resource、url、class来加载一个或多个映射配置文件）</li></ul><h4 id="2-2-映射配置文件"><a href="#2-2-映射配置文件" class="headerlink" title="2.2 映射配置文件"></a>2.2 映射配置文件</h4><p>在映射配置文件中，常用的标签如下：</p><ul><li><code>&lt;resultMap/&gt;</code>来指定数据库字段名和实体类属性的对应关系。</li><li><code>&lt;parameterType/&gt;</code>：参数类型</li><li><code>&lt;resultType/&gt;或&lt;resultMap/&gt;</code>：结果类型或者使用的结果集</li><li><code>&lt;select/&gt; &lt;insert/&gt; &lt;update/&gt; &lt;delete/&gt;</code>：定义增删改查的SQL语句</li></ul><p>常用的动态标签：</p><ul><li>where：使用该标签会自动去除第一个and，不需要写where 1=1</li><li>if：根据参数对象的取值进行不同条件的判断</li><li>foreach：进行数组的循环，通过open和close属性，生成类似 id in ()或者对map进行遍历</li><li>include：进行SQL片段抽取，避免同样的SQL的重复编写</li><li>choose、when、otherwise：进行条件判断，如果不符合就是要otherwise（相当于default）</li></ul><h3 id="3-复杂映射"><a href="#3-复杂映射" class="headerlink" title="3. 复杂映射"></a>3. 复杂映射</h3><blockquote><p>复杂映射，主要是为了解决一对一、一对多、多对多的映射关系</p></blockquote><h4 id="2-1-一对一"><a href="#2-1-一对一" class="headerlink" title="2.1 一对一"></a>2.1 一对一</h4><p>在此举例说明，现有两张表，一张用户表User，一张省信息表province。<br>一个人属于一个省，当查询User信息时，也要将所属的省信息查出，这时就符合所说的一对一映射查询。<br>如果通过SQL完成查询，对应的sql语句应该是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> u.name, p.pname <span class="keyword">from</span> province p,<span class="keyword">user</span> u <span class="keyword">where</span> u.pid<span class="operator">=</span>p.pid;</span><br></pre></td></tr></table></figure><p>反应在Java实体上，就是<code>User</code>类中，会声明一个<code>Province</code>的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long uid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Province province;</span><br><span class="line">........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在如果通过XML方式想要在查询用户时将省信息同时查出，需要用到<code>&lt;association/&gt;</code>标签。UserMapper.xml中的resultMap需要增加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.jfl.test.User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明一对一相关信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;province&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.jfl.test.Province&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;pid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;pname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中<code>&lt;association/&gt;</code>的property属性对应实体中的属性名，里面的标签对应Province的属性。<br>此时查询结果就是如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User&#123;id=<span class="number">1</span>,name=<span class="string">&#x27;tom&#x27;</span>,province=Province&#123;pid=<span class="number">1</span>,pname=<span class="string">&#x27;beijing&#x27;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-一对多"><a href="#2-2-一对多" class="headerlink" title="2.2 一对多"></a>2.2 一对多</h4><p>还是上面的例子，一个省对应多个人，这种情况下想要查询一对多，通过SQL查询的话，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> p.pid,p.pname,u.id,u.name <span class="keyword">from</span> province p <span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> u.pid<span class="operator">=</span>p.pid;</span><br></pre></td></tr></table></figure><p>反应在Java实体上，就是<code>Province</code>类中，会声明一个<code>List&lt;User&gt;</code>的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Province</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long pid;</span><br><span class="line">    <span class="keyword">private</span> String pname;</span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; userList;</span><br><span class="line">........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而mybatis的映射配置XML文件中，需要增加<code>&lt;collection /&gt;</code>配置，才可以支持一对多：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;provinceMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.jfl.test.Province&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;pid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;pname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;userList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.jfl.test.User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-多对多"><a href="#2-3-多对多" class="headerlink" title="2.3 多对多"></a>2.3 多对多</h4><p>此处举例说明，一个学生学习多门课程，每门课程也有很多学生来学习。此时学生和课程的对应关系就是多对多，通常这种情况，在数据库设计时会通过中间表来实现，模型如下图：<br><img src="https://img-blog.csdnimg.cn/20201022143803542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xmajM5NzQ=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>此时就可以将学生和课程的多对多，看成是学生表和学生课程关系表的一对多；同理，课程和学生的关系，也可以看成是课程表和学生课程关系表的一对多。<br>所以多对多，其实就是两个一对多，具体实现参考一对多。</p>]]></content>
      
      
      <categories>
          
          <category> 技术文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
